"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1364],{994:(n,e,o)=>{o.d(e,{A:()=>s});const s=o.p+"assets/images/rig_space_look_at-f7d7f664abc6f37dded24c9dd59ddc0d.png"},4345:(n,e,o)=>{o.d(e,{A:()=>s});const s=o.p+"assets/images/rig_look_at-415df47ddc93fa9338ce76309094013c.png"},6154:(n,e,o)=>{o.d(e,{A:()=>s});const s=o.p+"assets/images/rig_skull_mid-69e0a279ac3e331b2e39dc3f5d08d1da.png"},7406:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"guides/facial_rig/modifiers","title":"Adding Modifiers","description":"Now that the hierarchy is in place, we move on to the most interesting part: adding all the mechanics with the modifiers.","source":"@site/docs/guides/11-facial_rig/02-modifiers.md","sourceDirName":"guides/11-facial_rig","slug":"/guides/facial_rig/modifiers","permalink":"/mikan-docs/guides/facial_rig/modifiers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Template Hierarchy","permalink":"/mikan-docs/guides/facial_rig/templates"},"next":{"title":"Facial Poses and UI","permalink":"/mikan-docs/guides/facial_rig/facial_posing"}}');var t=o(4848),i=o(8453);const l={},r="Adding Modifiers",a={},d=[{value:"Visibility groups",id:"visibility-groups",level:2},{value:"rig skull mid",id:"rig-skull-mid",level:2},{value:"rig mouth",id:"rig-mouth",level:2},{value:"mouth hook",id:"mouth-hook",level:3},{value:"lip rechain",id:"lip-rechain",level:3},{value:"lips hooks",id:"lips-hooks",level:3},{value:"sticky corner switch _ pinch",id:"sticky-corner-switch-_-pinch",level:3},{value:"teeth subtransform _ grab teeth",id:"teeth-subtransform-_-grab-teeth",level:3},{value:"lips corner rig",id:"lips-corner-rig",level:3},{value:"Sticky Lips Rig",id:"sticky-lips-rig",level:3},{value:"Sticky teeth Rig",id:"sticky-teeth-rig",level:3},{value:"rig cheeks",id:"rig-cheeks",level:2},{value:"rig look at",id:"rig-look-at",level:2},{value:"look at space switch",id:"look-at-space-switch",level:2},{value:"2d eyes rig",id:"2d-eyes-rig",level:2},{value:"rig eyebrows",id:"rig-eyebrows",level:2}];function p(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"adding-modifiers",children:"Adding Modifiers"})}),"\n",(0,t.jsx)(e.p,{children:"Now that the hierarchy is in place, we move on to the most interesting part: adding all the mechanics with the modifiers."}),"\n",(0,t.jsx)(e.admonition,{type:"info",children:(0,t.jsx)(e.p,{children:"Reminder: in Mikan, we do not use direct constraints in Maya.\nWe use modifiers, which are instructions read by Mikan during the rig build.\nThis keeps the template clean and flexible."})}),"\n",(0,t.jsx)(e.h2,{id:"visibility-groups",children:"Visibility groups"}),"\n",(0,t.jsx)(e.p,{children:"Let's start with simple modifiers to add visibility groups to the facial-rig controllers."}),"\n",(0,t.jsxs)(e.p,{children:["Groups in the hierarchy gather controllers for select/mirror/flip, but they do not create visibility menus.\nSo we add a ",(0,t.jsx)(e.strong,{children:"helper node _face_vis"})," on the face group, then a ",(0,t.jsx)(e.strong,{children:"group modifier"})," to create the visibility menus."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- facial visibility groups\n#? neck::ctrls.head\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - face:::ctrls \n  tag: vis.face\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - mouth1*::ctrls  \n    - mouth2*::ctrls  \n    - mouth3*::ctrls  \n    - mouth4*::ctrls \n  tag: vis.mouth\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - lip1*::ctrls  \n    - lip2*::ctrls  \n    - lip3*::ctrls  \n    - lip4*::ctrls \n  tag: vis.lips\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - cheeks:::ctrls   \n  tag: vis.cheeks\n"})}),"\n",(0,t.jsx)(e.h2,{id:"rig-skull-mid",children:"rig skull mid"}),"\n",(0,t.jsxs)(e.p,{children:["Let's add the modifiers required to rig ",(0,t.jsx)(e.strong,{children:"skull_mid"}),".\nWe first attach skull_mid using a ",(0,t.jsx)(e.strong,{children:"hook"})," modifier between ",(0,t.jsx)(e.strong,{children:"skull"})," and ",(0,t.jsx)(e.strong,{children:"jaw_up"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- skull mid hooks\n\nhook:\n  nodes:\n   - skull_mid::roots\n  targets: \n   - skull::skin.0\n   - jaw_up::skin.0\n  self: on\n"})}),"\n",(0,t.jsxs)(e.p,{children:["We then create an attribute to ",(0,t.jsx)(e.strong,{children:"manage the follow"})," between the two targets, using a ",(0,t.jsx)(e.strong,{children:"plug"})," modifier."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n\nplug:\n  node: skull_mid::ctrls.0\n  slide: {k: on, min: 0, max: 1, set: $slide}\n\nconnect:\n  input: skull_mid::ctrls.0@slide\n  node: skull_mid::roots.0@w0\nconnect:\n  input: skull_mid::ctrls.0@slide\n  op: reverse\n  node: skull_mid::roots.0@w1\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{alt:"rig skull mid",src:o(6154).A+"",width:"1000",height:"730"})}),"\n",(0,t.jsx)(e.h2,{id:"rig-mouth",children:"rig mouth"}),"\n",(0,t.jsx)(e.h3,{id:"mouth-hook",children:"mouth hook"}),"\n",(0,t.jsxs)(e.p,{children:["We want ",(0,t.jsx)(e.strong,{children:"c_mouth"})," to be attached to ",(0,t.jsx)(e.strong,{children:"jaw"})," and ",(0,t.jsx)(e.strong,{children:"jaw_up"}),".\nWe create a ",(0,t.jsx)(e.strong,{children:"hook"})," modifier, synchronize its weights via a ",(0,t.jsx)(e.strong,{children:"connect"}),", and add a ",(0,t.jsx)(e.strong,{children:"plug"})," to easily adjust the blend."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- mouth rig\nhook:  \n  nodes: mouth::roots.0  \n  targets:   \n    - jaw_up::skin.0   \n    - jaw::skin.0  \n  group: on  \n  name: jaw_mid\n\nconnect:\n  input: mouth::mod.hooks.jaw_mid@w0\n  node: mouth::mod.hooks.jaw_mid@w1\n  op: reverse\n\nplug:\n  node: mouth::mod.hooks.jaw_mid\n  w0: {set: $jaw_mid_weight}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{alt:"rig mouth",src:o(8327).A+"",width:"1228",height:"740"})}),"\n",(0,t.jsx)(e.h3,{id:"lip-rechain",children:"lip rechain"}),"\n",(0,t.jsxs)(e.p,{children:["We want ",(0,t.jsx)(e.strong,{children:"mouth"})," and the ",(0,t.jsx)(e.strong,{children:"lips"})," to ",(0,t.jsx)(e.strong,{children:"follow jaw"}),", ",(0,t.jsx)(e.strong,{children:"jaw_up"}),", and ",(0,t.jsx)(e.strong,{children:"c_mouth"}),". To achieve this, we create a ",(0,t.jsx)(e.strong,{children:"_lips_mod"})," helper node on the lips group."]}),"\n",(0,t.jsx)(e.p,{children:"\ud83d\udc49 This cannot be done with simple parenting or constraints, as it would break the hierarchical dependencies."}),"\n",(0,t.jsxs)(e.p,{children:["We use a ",(0,t.jsx)(e.strong,{children:"rig.rechain"})," modifier to create a parallel virtual hierarchy and accumulate the influences.\nFirst, we parent lip_up under jaw_up and lip_dn under jaw.\nThen we add the rig.rechain so that the lips also follow c_mouth."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n#! -10\n\nparent: lip_up::roots.0 jaw_up::skin.0\nparent: lip_dn::roots.0 jaw::skin.0\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - lip_up::roots.0\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - lip_dn::roots.0\n"})}),"\n",(0,t.jsx)(e.h3,{id:"lips-hooks",children:"lips hooks"}),"\n",(0,t.jsx)(e.p,{children:"On the same helper node, we add modifiers to hook the c_mouth controllers with weight attributes, so we can manage the follow between mouth and lip_up / lip_dn."}),"\n",(0,t.jsx)(e.p,{children:"The intended behavior is:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"mouth1"})," fully follows the lips,"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"mouth4"})," stays entirely on mouth,"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"intermediate controllers"})," have ",(0,t.jsx)(e.strong,{children:"progressive follow values"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This gives a coherent and smooth deformation across the entire mouth line."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- lips up/dn hooks\n#> n: ['2', '2b', '3']\n#> side: [up, dn]\n\nhook:\n  node: mouth1_<side>::roots.0\n  targets:\n   - lip_<side>::skin.0\n  group: on\n  name: lip1_<side>\nhook:\n  node: mouth<n>_<side>::roots.0\n  targets:\n   - lip_<side>::skin.0\n   - mouth::skin.0\n  group: on\n  name: lip<n>_<side>\nhook:\n  nodes: mouth4::roots.0\n  targets:\n   - mouth::skin.0\n  group: on\n  name: lip4\n\nconnect:\n  input: lips::mod.hooks.lip<n>_<side>@w0\n  node: lips::mod.hooks.lip<n>_<side>@w1\n  op: reverse\n\nplug:\n  node: lips::mod.hooks.lip<n>_<side>\n  w0: {set: $mouth<n>_<side>_weight}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"sticky-corner-switch-_-pinch",children:"sticky corner switch _ pinch"}),"\n",(0,t.jsxs)(e.p,{children:["Still on the same helper, we add the modifiers to build a ",(0,t.jsx)(e.strong,{children:"sticky corner"})," system.\nWe create a ",(0,t.jsx)(e.strong,{children:"corners_pinch attribute"}),", then connect it to the ",(0,t.jsx)(e.strong,{children:"weights"})," of the hooks for mouth2 and mouth3."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky corner switch\n#> n: ['2', '2b']\n#> side: [up, dn]\nplug:\n  node: mouth::ctrls.0\n  corners_pinch: {set: 0, k: on, min: -1, max: 1}\n\ndrive:\n  node: mouth::ctrls.0@corners_pinch\n  lips::mod.hooks.lip<n>_<side>@w0:\n    1: $mouth<n>_<side>_weight\n    0: $mouth<n>_<side>_weight\n    -1: 1\n\ndrive:\n  node: mouth::ctrls.0@corners_pinch\n  lips::mod.hooks.lip3_<side>@w0:\n    1: 0\n    0: $mouth3_<side>_weight\n    -1: 1\n"})}),"\n",(0,t.jsx)(e.h3,{id:"teeth-subtransform-_-grab-teeth",children:"teeth subtransform _ grab teeth"}),"\n",(0,t.jsxs)(e.p,{children:["Following the same logic, we rig the ",(0,t.jsx)(e.strong,{children:"teeth"})," so they can ",(0,t.jsx)(e.strong,{children:"follow (or not) c_mouth"}),".\nWe create a ",(0,t.jsx)(e.strong,{children:"virtual hierarchy"})," between c_mouth and c_teeth, using the weight option to enable or disable the transform constraint."]}),"\n",(0,t.jsx)(e.p,{children:"We then add an attribute on c_mouth to control the weight of this constraint."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- teeth subtransform\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - teeth_up::roots.0\n  weight: on\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - teeth_dn::roots.0\n  weight: on\n\nplug:\n  node: mouth::ctrls.0\n  grab_teeth:\n    k: on\n    min: 0\n    max: 1\n\nconnect:\n  input: mouth::ctrls.0@grab_teeth\n  node: teeth_up::roots.0@weight\nconnect:\n  input: mouth::ctrls.0@grab_teeth\n  node: teeth_dn::roots.0@weight\n"})}),"\n",(0,t.jsx)(e.h3,{id:"lips-corner-rig",children:"lips corner rig"}),"\n",(0,t.jsx)(e.p,{children:"We now set up the connections so that mouth3 up/dn and mouth4 are driven by both c_mouth and c_corner, while still following lip_up and lip_dn."}),"\n",(0,t.jsx)(e.p,{children:"To do this, we again use rig.rechain, which allows us to build a virtual hierarchy without breaking existing dependencies."}),"\n",(0,t.jsx)(e.p,{children:"The order of the constraints is essential:\nthe mouth controllers must follow c_corner first, then lip_up/dn."}),"\n",(0,t.jsx)(e.p,{children:"We proceed as follows:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create locators under sk_mouth."}),"\n",(0,t.jsx)(e.li,{children:"Create additional locators under the hooks of mouth3 and mouth4, replacing the controllers."}),"\n",(0,t.jsx)(e.li,{children:"Reparent the mouth controllers under c_corner."}),"\n",(0,t.jsx)(e.li,{children:"Rebuild the hierarchy between the hooks and controllers using rig.rechain."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- mouth corner rig (subtransforms)\n\n#!-10\n#> lip: ['3_up', '4', '3_dn']\n\nlocator:\n  node: mouth<lip>.L::ctrls.0\n  parent: mouth::skin.0\n  name: orig_mouth_<lip>\n\nlocator:\n  node: mouth<lip>.L::ctrls.0\n  parent: lips::mod.hooks.lip<lip>\n  name: mouth_<lip>\n\nparent:\n  - mouth<lip>.L::roots.0\n  - lips_corner.L::skin.0\n\nrig.rechain:\n  roots:\n   - lips_corner.L::mod.loc.orig_mouth_<lip>\n  ctrls:\n   - lips_corner.L::mod.loc.mouth_<lip>\n  nodes:\n   - mouth<lip>.L::roots.0\n"})}),"\n",(0,t.jsx)(e.h3,{id:"sticky-lips-rig",children:"Sticky Lips Rig"}),"\n",(0,t.jsxs)(e.p,{children:["We start by creating the sticky attributes on ",(0,t.jsx)(e.strong,{children:"shp_lips"}),", which will later be connected to chan_face for animator access."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky lips settings\n#!10\n\nplug:\n m_sticky_L: {add: float, k: on, set: 0, min: 0, max: 2}\n m_sticky_R: {add: float, k: on, set: 0, min: 0, max: 2}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["We then set up the ",(0,t.jsx)(e.strong,{children:"sticky rig"})," by creating a helper ",(0,t.jsx)(e.strong,{children:"node"})," under the Lips group."]}),"\n",(0,t.jsxs)(e.p,{children:["We first create ",(0,t.jsx)(e.strong,{children:"midpoint locators"})," between up and dn for ",(0,t.jsx)(e.strong,{children:"lip1, lip2, and lip3"}),", then reference locators for up/dn positions."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky lips rig\n#!-5\n\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip1_mid\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2_mid.L\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2b_mid.L \nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip3_mid.L\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2_mid.R\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2b_mid.R\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip3_mid.R\n\n\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip1_mid\n  targets:\n   - mouth1_up::poses\n   - mouth1_dn::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2_mid.L\n  targets:\n   - mouth2_up.L::poses\n   - mouth2_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2b_mid.L\n  targets:\n   - mouth2b_up.L::poses\n   - mouth2b_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip3_mid.L\n  targets:\n   - mouth3_up.L::poses\n   - mouth3_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2_mid.R\n  targets:\n   - mouth2_up.R::poses\n   - mouth2_dn.R::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2b_mid.R\n  targets:\n   - mouth2b_up.R::poses\n   - mouth2b_dn.R::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip3_mid.R\n  targets:\n   - mouth3_up.R::poses\n   - mouth3_dn.R::poses\n\nlocator:\n  node: lip1_up::roots.0\n  parent: lips::mod.loc.lip1_mid\n  name: lip1_up\nlocator:\n  node: lip2_up.L::roots.0\n  parent: lips::mod.loc.lip2_mid.L\n  name: lip2_up.L\nlocator:\n  node: lip2b_up.L::roots.0\n  parent: lips::mod.loc.lip2b_mid.L\n  name: lip2b_up.L\nlocator:\n  node: lip3_up.L::roots.0\n  parent: lips::mod.loc.lip3_mid.L\n  name: lip3_up.L\nlocator:\n  node: lip2_up.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2_up.R\nlocator:\n  node: lip2b_up.R::roots.0\n  parent: lips::mod.loc.lip2b_mid.R\n  name: lip2b_up.R\nlocator:\n  node: lip3_up.R::roots.0\n  parent: lips::mod.loc.lip3_mid.R\n  name: lip3_up.R\n\nlocator:\n  node: lip1_dn::roots.0\n  parent: lips::mod.loc.lip1_mid\n  name: lip1_dn\nlocator:\n  node: lip2_dn.L::roots.0\n  parent: lips::mod.loc.lip2_mid.L\n  name: lip2_dn.L\nlocator:\n  node: lip2b_dn.L::roots.0\n  parent: lips::mod.loc.lip2b_mid.L\n  name: lip2b_dn.L\nlocator:\n  node: lip3_dn.L::roots.0\n  parent: lips::mod.loc.lip3_mid.L\n  name: lip3_dn.L\nlocator:\n  node: lip2_dn.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2_dn.R\nlocator:\n  node: lip2b_dn.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2b_dn.R\nlocator:\n  node: lip3_dn.R::roots.0\n  parent: lips::mod.loc.lip3_mid.R\n  name: lip3_dn.R\n\n\nhook:\n  node: lip1_up::infs.0\n  target: lips::mod.loc.lip1_up\n  weights: [1]\n\nhook:\n  node: lip1_dn::infs.0\n  target: lips::mod.loc.lip1_dn\n  weights: [1]\n\nhook:\n  node: lip2_up.L::infs.0\n  target: lips::mod.loc.lip2_up.L\n  weights: [1]\n\nhook:\n  node: lip2_dn.L::infs.0\n  target: lips::mod.loc.lip2_dn.L\n  weights: [1]\n\nhook:\n  node: lip2b_up.L::infs.0\n  target: lips::mod.loc.lip2b_up.L\n  weights: [1]\n\nhook:\n  node: lip2b_dn.L::infs.0\n  target: lips::mod.loc.lip2b_dn.L\n  weights: [1]\n\nhook:\n  node: lip3_up.L::infs.0\n  target: lips::mod.loc.lip3_up.L\n  weights: [1]\n\nhook:\n  node: lip3_dn.L::infs.0\n  target: lips::mod.loc.lip3_dn.L\n  weights: [1]\n\nhook:\n  node: lip2_up.R::infs.0\n  target: lips::mod.loc.lip2_up.R\n  weights: [1]\n\nhook:\n  node: lip2_dn.R::infs.0\n  target: lips::mod.loc.lip2_dn.R\n  weights: [1]\n\nhook:\n  node: lip2b_up.R::infs.0\n  target: lips::mod.loc.lip2b_up.R\n  weights: [1]\n\nhook:\n  node: lip2b_dn.R::infs.0\n  target: lips::mod.loc.lip2b_dn.R\n  weights: [1]\n\nhook:\n  node: lip3_up.R::infs.0\n  target: lips::mod.loc.lip3_up.R\n  weights: [1]\n\nhook:\n  node: lip3_dn.R::infs.0\n  target: lips::mod.loc.lip3_dn.R\n  weights: [1]\n"})}),"\n",(0,t.jsx)(e.p,{children:"Finally, we set up the drives and expressions controlling the sticky behavior."}),"\n",(0,t.jsx)(e.p,{children:"Start with values that seem reasonable. You can adjust them as you test the rig."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"drive:\n  node: shp_lips::node@m_sticky_L\n  shp_lips::node@s3l:\n    0: {v: 0, tan: linear}\n    0.25: {v: 0.5, ox: 0.25, oy: 0.5}\n    1: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2bl:\n    0: {v: 0, tan: flat}\n    0.375: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2l:\n    0: {v: 0, tan: flat}\n    0.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s1:\n    0.25: {v: 0, tan: flat}\n    1: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.75: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2r:\n    0.75: {v: 0, tan: flat}\n    1.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2br:\n    0.75: {v: 0, tan: flat}\n    1.625: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s3r:\n    1: {v: 0, tan: flat}\n    1.75: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: linear}\n    pre: constant\n    post: constant\n\ndrive:\n  node: shp_lips::node@m_sticky_R\n  shp_lips::node@s3r:\n    0: {v: 0, tan: linear}\n    0.25: {v: 0.5, ox: 0.25, oy: 0.5}\n    1: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  node: shp_lips::node@m_sticky_R\n  shp_lips::node@s2br:\n    0: {v: 0, tan: flat}\n    0.375: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2r:\n    0: {v: 0, tan: flat}\n    0.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s1:\n    0.25: {v: 0, tan: flat}\n    1: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.75: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2l:\n    0.75: {v: 0, tan: flat}\n    1.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2bl:\n    0.75: {v: 0, tan: flat}\n    1.625: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s3l:\n    1: {v: 0, tan: flat}\n    1.75: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: linear}\n    pre: constant\n    post: constant\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip3_up.L::infs.0@w0\n  x: shp_lips::node@s3l\n\nconnect:\n  input: lip3_up.L::infs.0@w0\n  node: lip3_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2b_up.L::infs.0@w0\n  x: shp_lips::node@s2bl\nconnect:\n  input: lip2b_up.L::infs.0@w0\n  node: lip2b_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2_up.L::infs.0@w0\n  x: shp_lips::node@s2l\n\nconnect:\n  input: lip2_up.L::infs.0@w0\n  node: lip2_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip1_up::infs.0@w0\n  x: shp_lips::node@s1\n\nconnect:\n  input: lip1_up::infs.0@w0\n  node: lip1_dn::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2_up.R::infs.0@w0\n  x: shp_lips::node@s2r\n\nconnect:\n  input: lip2_up.R::infs.0@w0\n  node: lip2_dn.R::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2b_up.R::infs.0@w0\n  x: shp_lips::node@s2br\n\nconnect:\n  input: lip2b_up.R::infs.0@w0\n  node: lip2b_dn.R::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip3_up.R::infs.0@w0\n  x: shp_lips::node@s3r\n\nconnect:\n  input: lip3_up.R::infs.0@w0\n  node: lip3_dn.R::infs.0@w0\n"})}),"\n",(0,t.jsx)(e.h3,{id:"sticky-teeth-rig",children:"Sticky teeth Rig"}),"\n",(0,t.jsxs)(e.p,{children:["The principle is the ",(0,t.jsx)(e.strong,{children:"same"})," as with the sticky lips, except the sticky should ",(0,t.jsx)(e.strong,{children:"activate uniformly"})," across all teeth.\nWe create a ",(0,t.jsx)(e.strong,{children:"_sticky_teeth helper node"})," under the Lips group to store these modifiers."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\nlocator:\n  node: teeth_dn::skin.0\n  parent: jaw::skin.0\n  name: teeth_mid\n\nhook:\n  self: on\n  targets:\n    - teeth_up::skin.0\n    - teeth_dn::skin.0\n  node: lips::mod.loc.teeth_mid\n  weights: [0.5, 0.5]\n\n#> y: [up, dn]\n#> x: [L, R]\nlocator:\n  node: teeth_bend_<y>.<x>::poses.0\n  parent: lips::mod.loc.teeth_mid\n  name: copy_teeth_tip_<y>_<x>\n  copycat: on\n\nlocator:\n  node: teeth_tip_<y>::hooks.0\n  parent: lips::mod.loc.teeth_mid\n  name: teeth_tip_<y>\nlocator:\n  node: teeth_bend_tip_<y>.<x>::hooks.0\n  parent: lips::mod.loc.copy_teeth_tip_<y>_<x>\n  name: teeth_tip_<y>_<x>\n\nhook:\n  target: lips::mod.loc.teeth_tip_<y>\n  node: teeth_tip_<y>::roots.0\n  weights: [1]\nhook:\n  target: lips::mod.loc.teeth_tip_<y>_<x>\n  node: teeth_bend_tip_<y>.<x>::roots.0\n  weights: [1]\n\n\nplug:\n  node: shp_lips::node\n  t_sticky: {type: float, k: on}\n\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_tip_<y>::roots.0@w0\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_tip_<y>::roots.0@w1\n  op: reverse\n\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_bend_tip_<y>.<x>::roots.0@w0\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_bend_tip_<y>.<x>::roots.0@w1\n  op: reverse\n"})}),"\n",(0,t.jsx)(e.h2,{id:"rig-cheeks",children:"rig cheeks"}),"\n",(0,t.jsxs)(e.p,{children:["Next, we rig the ",(0,t.jsx)(e.strong,{children:"cheeks"})," by attaching their controllers to the facial structure.\nWe add ",(0,t.jsx)(e.strong,{children:"hook"})," modifiers on a helper node placed under skull_mid."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\nparent:\n  - chin::roots\n  - jaw::hooks.0\n\nhook:\n  nodes:\n   - cheek1::roots\n   - nasolabial1::roots\n  targets:\n   - jaw_up::skin.0\n   - jaw::skin.0\n  parent: neck::hooks.head\n  name: cheek_mid\n\nhook:\n  nodes:\n   - cheek2::roots\n   - cheek3::roots\n  targets:\n   - skull::skin.0\n   - skull_mid::skin.0\n   - jaw_up::skin.0\n  weights: [0.35, 0.5, 0.15]\n  parent: neck::hooks.head\n  name: cheek_nose\n\nhook:\n  nodes:\n   - nasolabial2::roots\n   - lip_upper::roots\n  targets:\n   - jaw_up::skin.0\n   - skull_mid::skin.0\n  weights: [0.65, 0.35]\n  parent: neck::hooks.head\n  name: jaw_up_nose\n"})}),"\n",(0,t.jsx)(e.h2,{id:"rig-look-at",children:"rig look at"}),"\n",(0,t.jsxs)(e.p,{children:["We now move on to the ",(0,t.jsx)(e.strong,{children:"look-at rig"}),".\nWe add a ",(0,t.jsx)(e.strong,{children:"constraint"})," modifier to create an aim constraint between eye_ball and look_target."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- look at rig\n\nconstraint:\n  type: aim\n  node: eye_ball.L::roots.0\n  targets: look_target.L::ctrls\n  maintain_offset: on\n  flip: on\n  aim: [0, 0, 1]\n  up: [0, 0, 0]\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{alt:"rig look_at",src:o(4345).A+"",width:"400",height:"479"})}),"\n",(0,t.jsx)(e.h2,{id:"look-at-space-switch",children:"look at space switch"}),"\n",(0,t.jsxs)(e.p,{children:["We add a ",(0,t.jsx)(e.strong,{children:"space"})," modifier to implement a space switch for the look-at control."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'[mod]\nspace:\n  node: look_at::ctrls.0\n  rest_name: eyes\n  targets:\n    - "*::space.world"\n    - "*::space.move"\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{alt:"rig space look_at",src:o(994).A+"",width:"490",height:"554"})}),"\n",(0,t.jsx)(e.h2,{id:"2d-eyes-rig",children:"2d eyes rig"}),"\n",(0,t.jsxs)(e.p,{children:["Now let's create the 2D eye rig.\nWe connect the ",(0,t.jsx)(e.strong,{children:"frame_look"})," (look + look_eye) interface to the eyes, and add two attributes: ",(0,t.jsx)(e.strong,{children:"cross"})," and ",(0,t.jsx)(e.strong,{children:"dizzy"}),"."]}),"\n",(0,t.jsx)(e.p,{children:"We create a helper on look, add a plug, then drive modifiers."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- 2d eyes rig\n\nplug:\n  t.x: {min: -1, max: 1}\n  t.y: {min: -1, max: 1}\n  t.z: {l: on, k: off}\n  r: {k: off, l: on}\n  s: {k: off, l: on}\n  cross: {k: on}\n  dizzy: {k: on}\n\ndrive:\n  plug: look::ctrls.0@cross\n  eye_ball.L::poses.0:\n    r.y: {0: 0, -1: $amp_ry}\n  eye_ball.R::poses.0:\n    r.y: {0: 0, -1: $amp_ry}\n\ndrive:\n  plug: look::ctrls.0@dizzy\n  eye.L::poses.0:\n    r.z: {0: 0, -1: 30}\n  eye.R::poses.0:\n    r.z: {0: 0, 1: 30}\n\n\ndrive:\n  plug: loc_look.L::node@t.x\n  driven:\n    eye_ball.L::poses.0:\n      r.y: {0: 0, 1: $amp_ry}\ndrive:\n  plug: loc_look.R::node@t.x\n  driven:\n    eye_ball.R::poses.0:\n      r.y: {0: 0, -1: $amp_ry}\n\ndrive:\n  plug: loc_look.L::node@t.y\n  driven:\n    eye_ball.L::poses.0:\n      r.x: {0: 0, -1: $amp_rx}\ndrive:\n  plug: loc_look.R::node@t.y\n  driven:\n    eye_ball.R::poses.0:\n      r.x: {0: 0, -1: $amp_rx}\n\n[mod]\n#!~dev, ~debug\n#!-10\nplug:\n  cross: $cross\n"})}),"\n",(0,t.jsxs)(e.p,{children:["If you look at the notes, you will see the introduction of ",(0,t.jsx)(e.strong,{children:"gem_var variables"}),", which we will set as follows:"]}),"\n",(0,t.jsx)(e.p,{children:"gem_var_amp_Rx : 30\ngem_var_amp_Ry : 30\ngem_cross_var : 0.15"}),"\n",(0,t.jsx)(e.admonition,{type:"tip",children:(0,t.jsxs)(e.p,{children:["You do not need to manually create ",(0,t.jsx)(e.code,{children:"gem_var"})," attributes. Mikan automatically generates missing ones using the proper naming convention during the build process."]})}),"\n",(0,t.jsxs)(e.p,{children:["And we add a ",(0,t.jsx)(e.strong,{children:"constraint"})," modifier on ",(0,t.jsx)(e.strong,{children:"loc_look"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\nconstraint:\n  type: point\n  node: loc_look.L::node\n  target: look_eye.L::ctrls.0\n"})}),"\n",(0,t.jsx)(e.h2,{id:"rig-eyebrows",children:"rig eyebrows"}),"\n",(0,t.jsxs)(e.p,{children:["We finish with the eyebrows rig.\nWe add a ",(0,t.jsx)(e.strong,{children:"hook"})," constraint so the eyebrows can either ",(0,t.jsx)(e.strong,{children:"follow or ignore"})," the eyeroots.\nWe use a helper node on eyebrow_base, with a ",(0,t.jsx)(e.strong,{children:"hook"})," modifier and a ",(0,t.jsx)(e.strong,{children:"follow plug"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"[mod]\nhook:\n  self: on\n  node: eyebrow_base.L::roots.0\n  target: eye_root.L::skin.0\n  weight: 1\n\nplug:\n  node: eyebrow_base.L::ctrls.0\n  follow_skull: {set: 0, k: on, min: 0, max: 1}\n\nconnect:\n  input: eyebrow_base.L::ctrls.0@follow_skull\n  op: reverse\n  node: eyebrow_base.L::roots.0@w0\n"})})]})}function c(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(p,{...n})}):p(n)}},8327:(n,e,o)=>{o.d(e,{A:()=>s});const s=o.p+"assets/images/rig_mouth-de1176b812cae40af070ba894654b74d.png"},8453:(n,e,o)=>{o.d(e,{R:()=>l,x:()=>r});var s=o(6540);const t={},i=s.createContext(t);function l(n){const e=s.useContext(i);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);