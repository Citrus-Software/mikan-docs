"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2930],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(96540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},78566:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"developer/overview","title":"Architecture Overview","description":"This section provides a technical deep-dive into how Mikan bridges the gap between a DCC scene (Maya, Tangerine) and its Python framework. Understanding this architecture is essential for extending the framework or integrating it into a production pipeline.","source":"@site/docs/developer/01-overview.md","sourceDirName":"developer","slug":"/developer/overview","permalink":"/mikan-docs/developer/overview","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Facial Poses and UI","permalink":"/mikan-docs/guides/facial_rig/facial_posing"},"next":{"title":"Authoring Templates","permalink":"/mikan-docs/developer/extending/template"}}');var s=i(74848),r=i(28453);const o={},a="Architecture Overview",c={},l=[{value:"Core Design Philosophy",id:"core-design-philosophy",level:2},{value:"Package Structure",id:"package-structure",level:3},{value:"The Object Model",id:"the-object-model",level:2},{value:"Class Hierarchy",id:"class-hierarchy",level:3},{value:"The <code>Asset</code> Class (The Orchestrator)",id:"the-asset-class-the-orchestrator",level:4},{value:"The Component Classes",id:"the-component-classes",level:4},{value:"Discovery &amp; Instantiation",id:"discovery--instantiation",level:2},{value:"The Identification Protocol",id:"the-identification-protocol",level:3},{value:"Context &amp; Data Flow",id:"context--data-flow",level:3},{value:"The Build Lifecycle",id:"the-build-lifecycle",level:2},{value:"1. Parsing &amp; Validation",id:"1-parsing--validation",level:3},{value:"2. Scheduling",id:"2-scheduling",level:3},{value:"3. Execution (The make loop)",id:"3-execution-the-make-loop",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"architecture-overview",children:"Architecture Overview"})}),"\n",(0,s.jsx)(n.p,{children:"This section provides a technical deep-dive into how Mikan bridges the gap between a DCC scene (Maya, Tangerine) and its Python framework. Understanding this architecture is essential for extending the framework or integrating it into a production pipeline."}),"\n",(0,s.jsx)(n.h2,{id:"core-design-philosophy",children:"Core Design Philosophy"}),"\n",(0,s.jsxs)(n.p,{children:["Mikan functions as a ",(0,s.jsx)(n.strong,{children:"stateless translation layer"}),". It does not maintain a permanent database of the rig; instead, it reads the current state of the scene graph (DAG) to instantiate Python objects on the fly."]}),"\n",(0,s.jsx)(n.p,{children:"The framework is organized into three distinct layers:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Abstract Core"}),": Defines the logic independent of the software (Base logic, Math, Solvers)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DCC Implementation"}),": Implements the abstract methods for specific software (Maya, Tangerine)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Content Modules"}),": The actual library of rigging components (Arms, Legs, Spines) derived from the layers above."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"package-structure",children:"Package Structure"}),"\n",(0,s.jsx)(n.p,{children:"The codebase is structured to enforce this separation:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Namespace"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mikan.core.abstract"})}),(0,s.jsx)(n.td,{children:"Contains the base classes (Asset, Template, Mod, Deformer). These define the contract but contain no DCC-specific code."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mikan.[dcc].core"})}),(0,s.jsx)(n.td,{children:"e.g., mikan.maya.core. Contains the concrete implementations. This is where calls to maya.cmds or tangerine.api happen"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mikan.templates"})}),(0,s.jsx)(n.td,{children:"Contains the rig components themselves. Each component includes a generic configuration (YAML) and a DCC-specific implementation file."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"the-object-model",children:"The Object Model"}),"\n",(0,s.jsxs)(n.p,{children:["Unlike some frameworks where every object inherits from a single ",(0,s.jsx)(n.code,{children:"Node"})," class, Mikan uses distinct orchestrators for different aspects of the rig."]}),"\n",(0,s.jsx)(n.h3,{id:"class-hierarchy",children:"Class Hierarchy"}),"\n",(0,s.jsxs)(n.h4,{id:"the-asset-class-the-orchestrator",children:["The ",(0,s.jsx)(n.code,{children:"Asset"})," Class (The Orchestrator)"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Asset"})," is the entry point of the API. It represents the root of a rig in the scene. It does not inherit from ",(0,s.jsx)(n.code,{children:"Template"}),", but acts as the manager for the entire build process."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Role"}),": Scene parsing, validation, and build execution."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identification"}),": Wraps a DAG transform node tagged with ",(0,s.jsx)(n.code,{children:'gem_type="asset"'}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Method"}),": ",(0,s.jsx)(n.code,{children:"asset.make()"})," triggers the rig build."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"the-component-classes",children:"The Component Classes"}),"\n",(0,s.jsx)(n.p,{children:"The rig content is defined by three primary module types:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Template"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Representation: A hierarchy of DAG nodes (Guides/Joints)."}),"\n",(0,s.jsx)(n.li,{children:"Discovery: Identified via attributes on nodes (e.g., gem_type string)."}),"\n",(0,s.jsx)(n.li,{children:"Logic: Defines structure, joint placement, and control generation."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modifier (Mod)"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Representation: "Code blocks" or metadata strings attached to a node.'}),"\n",(0,s.jsx)(n.li,{children:"Logic: Post-build script execution (custom constraints, math nodes)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deformer"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Representation: Links a Geometry Transform to a Deformer logic node."}),"\n",(0,s.jsx)(n.li,{children:"Logic: Handles binding (Skinning, Wraps, Muscles)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"discovery--instantiation",children:"Discovery & Instantiation"}),"\n",(0,s.jsx)(n.p,{children:"How does Mikan turn a Maya node into a Python object?"}),"\n",(0,s.jsxs)(n.p,{children:["Mikan relies on a ",(0,s.jsx)(n.strong,{children:'"Cast on Demand"'})," approach. While you can manually instantiate a wrapper (e.g., ",(0,s.jsx)(n.code,{children:"Template('tpl_arm')"}),"), the ",(0,s.jsx)(n.code,{children:"Asset"})," class typically handles discovery automatically."]}),"\n",(0,s.jsx)(n.h3,{id:"the-identification-protocol",children:"The Identification Protocol"}),"\n",(0,s.jsx)(n.p,{children:"Mikan scans the scene hierarchy looking for specific markers (attributes)."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"gem_type"}),": Defines the class type (e.g., ",(0,s.jsx)(n.code,{children:"asset"}),", ",(0,s.jsx)(n.code,{children:"template"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"gem_template"}),": Defines the template type (e.g., ",(0,s.jsx)(n.code,{children:"world.character"}),", ",(0,s.jsx)(n.code,{children:"arm.legacy"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"gem_id"}),": Defines the unique identifier/name within the rig."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Internal Logic Example (Pseudo-code)\nnode = mx.encode("asset")\n\nif "gem_type" in node and node["gem_type"] == "asset":\n    # Valid Asset Root found\n    my_asset = mikan.maya.core.asset.Asset(node)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"context--data-flow",children:"Context & Data Flow"}),"\n",(0,s.jsx)(n.p,{children:'Mikan does not pass a single "Global Context" object wildly. Instead, it relies on strict hierarchy and ID tagging.'}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configuration (YAML)"}),': Static options for templates (e.g., "Default IK Stretch").']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Instance Data (Attributes)"}),": User overrides stored on the DAG nodes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Runtime Connectivity (The ",(0,s.jsx)(n.code,{children:"Nodes"})," Class)"]}),": During the build, modules tag generated nodes with specific IDs. The Nodes utility class acts as a directory service, allowing modules to find each other (e.g., an Arm finding the Spine's end joint) without hardcoded paths."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-build-lifecycle",children:"The Build Lifecycle"}),"\n",(0,s.jsxs)(n.p,{children:["Executing a build (",(0,s.jsx)(n.code,{children:"asset.make()"}),") follows a strict sequence to ensure dependencies are respected."]}),"\n",(0,s.jsx)(n.h3,{id:"1-parsing--validation",children:"1. Parsing & Validation"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Asset"})," instance scans its hierarchy. It creates python instances for every valid ",(0,s.jsx)(n.code,{children:"Template"}),", ",(0,s.jsx)(n.code,{children:"Mod"}),", and ",(0,s.jsx)(n.code,{children:"Deformer"})," found in the DAG under the asset root."]}),"\n",(0,s.jsx)(n.h3,{id:"2-scheduling",children:"2. Scheduling"}),"\n",(0,s.jsx)(n.p,{children:"Mikan calculates the dependency order. Since templates are hierarchical, parent templates (like a Spine) must be built before children templates (like an Arm)."}),"\n",(0,s.jsx)(n.h3,{id:"3-execution-the-make-loop",children:"3. Execution (The make loop)"}),"\n",(0,s.jsx)(n.p,{children:"The build engine iterates through the sorted modules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pre-Build: Clean up previous rig nodes."}),"\n",(0,s.jsx)(n.li,{children:"Template Build: Generate joints, controls, and mechanisms."}),"\n",(0,s.jsx)(n.li,{children:"Modifier Execution: Apply custom logic and patches."}),"\n",(0,s.jsx)(n.li,{children:"Deformer Binding: Bind geometry to the new structure."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);