"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1704],{2663:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"usage/modifiers","title":"Modifiers and IDs","description":"Overview","source":"@site/docs/usage/modifiers.md","sourceDirName":"usage","slug":"/usage/modifiers","permalink":"/mikan-docs/usage/modifiers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Template Blueprints","permalink":"/mikan-docs/usage/blueprints"},"next":{"title":"Deformers","permalink":"/mikan-docs/usage/deformers"}}');var r=n(4848),l=n(8453);const d={sidebar_position:2},t="Modifiers and IDs",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Modifiers",id:"modifiers",level:2},{value:"Purpose",id:"purpose",level:3},{value:"Interface and Placement",id:"interface-and-placement",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Syntax",id:"syntax",level:3},{value:"Execution",id:"execution",level:3},{value:"Branching &amp; Duplication",id:"branching--duplication",level:3},{value:"Priorities",id:"priorities",level:3},{value:"Variables",id:"variables",level:3},{value:"Iterators",id:"iterators",level:3},{value:"Conditions",id:"conditions",level:3},{value:"Mikan Identifiers (IDs)",id:"mikan-identifiers-ids",level:2},{value:"Rig ID Structure",id:"rig-id-structure",level:3},{value:"Branching and Wildcards",id:"branching-and-wildcards",level:3},{value:"Geometry ID Structure",id:"geometry-id-structure",level:3},{value:"Geometry Tags",id:"geometry-tags",level:3},{value:"Standard Plugs",id:"standard-plugs",level:3},{value:"Summary",id:"summary",level:2}];function o(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"modifiers-and-ids",children:"Modifiers and IDs"})}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(i.p,{children:["Mikan allows you to describe rig structures abstractly, independently of the DCC that generates them. A key feature of this system is the use of ",(0,r.jsx)(i.a,{href:"#mikan-identifiers-ids",children:(0,r.jsx)(i.strong,{children:"identifiers (IDs)"})})," to reference nodes and geometry across different commands and tools \u2014 particularly modifiers."]}),"\n",(0,r.jsxs)(i.p,{children:["Modifiers are procedural instructions that are executed ",(0,r.jsx)(i.strong,{children:"after the template hierarchy is built"}),", enabling actions like constraints, driven keys, reparenting, and more. To reference rig elements within these commands, Mikan uses a consistent ID system. This document covers both concepts: how to ",(0,r.jsx)(i.strong,{children:"write modifiers"})," and how to ",(0,r.jsx)(i.strong,{children:"use IDs"})," effectively within them."]}),"\n",(0,r.jsx)(i.h2,{id:"modifiers",children:"Modifiers"}),"\n",(0,r.jsx)(i.h3,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsxs)(i.p,{children:["Modifiers are YAML-formatted blocks that live in the ",(0,r.jsx)(i.code,{children:"notes"})," attribute of a node (by default in Maya). They are parsed and executed after the hierarchy is built, and allow procedural edits to the rig."]}),"\n",(0,r.jsx)(i.p,{children:"Typical operations include:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Constraints"}),"\n",(0,r.jsx)(i.li,{children:"Driven keys"}),"\n",(0,r.jsx)(i.li,{children:"Parenting"}),"\n",(0,r.jsx)(i.li,{children:"Plug manipulations"}),"\n",(0,r.jsx)(i.li,{children:"Custom rig"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Modifiers make rigging declarative, structured, and portable across platforms."}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"interface-and-placement",children:"Interface and Placement"}),"\n",(0,r.jsxs)(i.p,{children:["Modifiers can be added ",(0,r.jsx)(i.strong,{children:"anywhere in the blueprint"}),": either directly on a node inside a template module or, preferably, on a ",(0,r.jsx)(i.strong,{children:"helper node"})," for better clarity and modularity."]}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Right-click"})," a node in the Blueprint Outliner."]}),"\n",(0,r.jsxs)(i.li,{children:["Choose \u201c",(0,r.jsx)(i.strong,{children:"Add Modifier"}),"\u201d from the context menu."]}),"\n",(0,r.jsxs)(i.li,{children:["(Optional) If you want to isolate the modifier logic, first create a ",(0,r.jsx)(i.strong,{children:"Helper Node"})," using \u201c",(0,r.jsx)(i.strong,{children:"Add Helper Node"}),"\u201d, then add the modifier to it."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["Once added, the modifier appears as an inline ",(0,r.jsx)(i.strong,{children:"editable text block"})," in the Edit tab in the bottom panel."]}),"\n",(0,r.jsx)(i.p,{children:"\ud83d\udfe3 Additionally, a new \u201cModifiers\u201d entry will appear in the Blueprint Outliner, highlighted in purple for easy identification."}),"\n",(0,r.jsx)(i.p,{children:"\ud83d\udca1 When selecting a node in the rig\u2019s viewport, its Mikan ID(s) will show up in the modifier editor. This provides quick reference to help write valid commands \u2014 especially useful when first learning the syntax."}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(i.p,{children:"The modifier system is intentionally open-ended \u2014 a powerful sandbox that enables complex, creative rig behaviors. But with great flexibility comes the risk of disorder."}),"\n",(0,r.jsxs)(i.p,{children:["Avoid scattering modifiers randomly across the blueprint. Instead, try to ",(0,r.jsx)(i.strong,{children:"group related modifiers"})," together logically, and attach them at meaningful points in the hierarchy \u2014 ideally under helper nodes when they represent standalone functionality."]}),"\n",(0,r.jsxs)(i.p,{children:["When modifiers contribute to a specific feature or behavior, consider organizing them into ",(0,r.jsx)(i.strong,{children:"cohesive blocks"}),". This makes it easier to ",(0,r.jsx)(i.strong,{children:"reuse"}),", disable, or remove functionality later without unintended side effects."]}),"\n",(0,r.jsxs)(i.p,{children:["We\u2019ll be adding a few guides to showcase best practices and advanced prototyping \u2014 for instance, how to build a fully modular eyelid rig using only a few ",(0,r.jsx)(i.code,{children:"core.joints"})," blocks combined with layered modifiers."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsxs)(i.p,{children:["Modifiers must be written inside ",(0,r.jsx)(i.code,{children:"[mod]"})," blocks using YAML. Each block can include one or more commands, each defined as a key-value pair."]}),"\n",(0,r.jsx)(i.p,{children:"Example:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"[mod]\ncommand:\n  node:\n    - key: value\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Indentation must use ",(0,r.jsx)(i.strong,{children:"spaces"})," (no tabs)."]}),"\n",(0,r.jsxs)(i.li,{children:["Use a space after ",(0,r.jsx)(i.code,{children:":"})," and after ",(0,r.jsx)(i.code,{children:","})," in lists or dictionaries."]}),"\n",(0,r.jsx)(i.li,{children:"Keys can be repeated to allow multiple commands of the same type."}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["Each ",(0,r.jsx)(i.code,{children:"[mod]"})," block can be configured with ",(0,r.jsx)(i.strong,{children:"priority"}),", ",(0,r.jsx)(i.strong,{children:"loop variables"}),", or ",(0,r.jsx)(i.strong,{children:"conditional execution"})," via special inline comments."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"execution",children:"Execution"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Modifiers are evaluated ",(0,r.jsx)(i.strong,{children:"top-down"})," during the template\u2019s execution pass."]}),"\n",(0,r.jsx)(i.li,{children:"IDs must be valid Mikan IDs (rig or geometry). Raw node names are not supported."}),"\n",(0,r.jsx)(i.li,{children:"If a referenced ID does not yet exist, the modifier will be deferred to the end of the stack."}),"\n",(0,r.jsx)(i.li,{children:"Deferred commands that still can\u2019t resolve their target will be discarded."}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"branching--duplication",children:"Branching & Duplication"}),"\n",(0,r.jsx)(i.p,{children:"Modifiers follow the branching rules of the template. If a template is instantiated multiple times (e.g. for left/right limbs), modifiers are automatically duplicated with the correct ID substitutions."}),"\n",(0,r.jsx)(i.p,{children:"To prevent a modifier from duplicating across branches, use:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"#/solo\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Mirror-aware behavior is applied automatically for flipped branches (",(0,r.jsx)(i.code,{children:".R"}),", ",(0,r.jsx)(i.code,{children:".bk"}),", ",(0,r.jsx)(i.code,{children:".dn"}),"). Some modifiers may require the ",(0,r.jsx)(i.code,{children:"flip: on"})," option to apply mirrored transformations (e.g. negating translation values)."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"priorities",children:"Priorities"}),"\n",(0,r.jsx)(i.p,{children:"Priorities are declared using:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"#! <priority_level>\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Higher numbers run earlier. Priorities apply ",(0,r.jsx)(i.strong,{children:"per [mod] block"}),". Use separate blocks for multiple priority levels."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"variables",children:"Variables"}),"\n",(0,r.jsx)(i.p,{children:"Instead of hardcoding values, use modifier variables like:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"$value\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Mikan will resolve it at build time from the ",(0,r.jsx)(i.code,{children:"gem_var_<name>"})," attribute on the node. If it doesn't exist, it will be created."]}),"\n",(0,r.jsx)(i.p,{children:"To bind a variable to another plug, use:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"#$ variable: path->xfo@plug\n"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"iterators",children:"Iterators"}),"\n",(0,r.jsx)(i.p,{children:"Use iterators to repeat commands with different values. Syntax:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"#> var: [item1, item2, item3]\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Within the modifier, use ",(0,r.jsx)(i.code,{children:"<var>"})," for substitution."]}),"\n",(0,r.jsx)(i.p,{children:"For value pairs:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"#> pair: [[v1, u1], [v2, u2]]\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Use ",(0,r.jsx)(i.code,{children:"<pair.0>"})," and ",(0,r.jsx)(i.code,{children:"<pair.1>"})," in the body."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"conditions",children:"Conditions"}),"\n",(0,r.jsx)(i.p,{children:"Execute modifiers only if a condition is met:"}),"\n",(0,r.jsx)(i.p,{children:"Check for presence of a node:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"#? meshA->xfo\n"})}),"\n",(0,r.jsx)(i.p,{children:"Check plug values:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"#? module::template@gem_flag\n#? module::template@gem_count 2\n#? module::template@gem_level <= 2\n"})}),"\n",(0,r.jsx)(i.p,{children:"Check variable values:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"#? $flag\n#? $mode 2\n#? $count <= 2\n"})}),"\n",(0,r.jsx)(i.p,{children:"\u26a0\ufe0f Make sure the attribute used in a modifier is properly available at build time. A common mistake is forgetting to include specific plugs in the Alembic export, which can cause the modifier to fail silently."}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"mikan-identifiers-ids",children:"Mikan Identifiers (IDs)"}),"\n",(0,r.jsx)(i.p,{children:"Mikan uses a standardized system of identifiers to refer to nodes and geometry across rigs and modifiers."}),"\n",(0,r.jsx)(i.p,{children:"There are two primary types of IDs:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Rig IDs"})," \u2013 to reference nodes in the rig hierarchy or template"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Geometry IDs"})," \u2013 to reference geometry or deformation nodes"]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"rig-id-structure",children:"Rig ID Structure"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-json",children:"[{asset}#]{template}[.{branch}]*::{tag}[.{key}]*[@{plug}]\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"asset"})," (optional): name of the asset (used in multi-asset rigs)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"template"}),": name of the template module"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"branch"})," (optional, repeatable): branch identifiers"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"tag"}),": type of element (e.g. ",(0,r.jsx)(i.code,{children:"roots"}),", ",(0,r.jsx)(i.code,{children:"ctrls"}),", ",(0,r.jsx)(i.code,{children:"node"}),")"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"key"})," (optional): specific instance(s)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"plug"})," (optional): attribute or plug (e.g. ",(0,r.jsx)(i.code,{children:"@t.x"}),")"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Example:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"spine::ctrls.pelvis"})," \u2013 pelvis controller from spine template"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"arm.L::skin"})," \u2013 all skin joints from left arm"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"arm:::ctrls"})," \u2013 all controllers from ",(0,r.jsx)(i.code,{children:"arm"})," and its child templates"]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"gem_id"})," attribute stores node IDs, separated by ",(0,r.jsx)(i.code,{children:";"})," if multiple."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"branching-and-wildcards",children:"Branching and Wildcards"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Hierarchical structure is represented with ",(0,r.jsx)(i.code,{children:"."})," in forks and keys."]}),"\n",(0,r.jsxs)(i.li,{children:["Use ",(0,r.jsx)(i.code,{children:":::"})," to include children templates."]}),"\n",(0,r.jsxs)(i.li,{children:["Use wildcards (",(0,r.jsx)(i.code,{children:"*"}),") to match multiple templates or keys.","\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"leg::ctrls"})," is the same as ",(0,r.jsx)(i.code,{children:"leg.*::ctrls.*"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"branch*::ctrls"})," will get you all controllers from all templates starting with ",(0,r.jsx)(i.code,{children:"branch"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"geometry-id-structure",children:"Geometry ID Structure"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-json",children:"[{asset}#]{path}->{tag}[.{key}]*[@{plug}]\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"path"}),": transform node address (Alembic notation used if needed)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"tag"}),": type of element (e.g. ",(0,r.jsx)(i.code,{children:"shape"}),", ",(0,r.jsx)(i.code,{children:"source"}),", ",(0,r.jsx)(i.code,{children:"xfo"}),")"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"key"}),": specific identifier"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"plug"}),": attribute name"]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["Geometry IDs resolve to a ",(0,r.jsx)(i.strong,{children:"transform/geometry pair"}),"."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"geometry-tags",children:"Geometry Tags"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"shape"}),": first visible shape under transform"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"source"}),": shape origin of deform stack"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"xfo"}),": transform node itself (useful for plug access)"]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"standard-plugs",children:"Standard Plugs"}),"\n",(0,r.jsx)(i.p,{children:"To ensure cross-DCC compatibility, use Mikan\u2019s unified plug names:"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Purpose"}),(0,r.jsx)(i.th,{children:"Plug"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Translate"}),(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"@t.x"}),", ",(0,r.jsx)(i.code,{children:"@t.y"}),", ",(0,r.jsx)(i.code,{children:"@t.z"})]})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Rotate"}),(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"@r.x"}),", ",(0,r.jsx)(i.code,{children:"@r.y"}),", ",(0,r.jsx)(i.code,{children:"@r.z"})]})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Scale"}),(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"@s.x"}),", ",(0,r.jsx)(i.code,{children:"@s.y"}),", ",(0,r.jsx)(i.code,{children:"@s.z"})]})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Visibility"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"@vis"})})]})]})]}),"\n",(0,r.jsxs)(i.p,{children:["Unknown plugs will be created as ",(0,r.jsx)(i.code,{children:"float"})," by default."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Use ",(0,r.jsx)(i.code,{children:"[mod]"})," blocks in ",(0,r.jsx)(i.code,{children:"notes"})," for procedural rigging."]}),"\n",(0,r.jsx)(i.li,{children:"Use Mikan IDs to reference nodes and geometry robustly."}),"\n",(0,r.jsx)(i.li,{children:"Branching, variables, priorities, iterators, and conditions provide powerful modifier control."}),"\n",(0,r.jsx)(i.li,{children:"Keep plug naming and IDs DCC-agnostic to ensure portability."}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"For more detailed information on each modifier type, refer to the corresponding reference pages."})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>d,x:()=>t});var s=n(6540);const r={},l=s.createContext(r);function d(e){const i=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),s.createElement(l.Provider,{value:i},e.children)}}}]);