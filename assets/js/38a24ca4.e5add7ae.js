"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[87],{7265:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>a,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"references/mod/rig/muscle","title":"rig.muscle","description":"Builds a muscle rig that stretches, squashes, and shears between two targets.","source":"@site/docs/references/mod/rig/muscle.md","sourceDirName":"references/mod/rig","slug":"/references/mod/rig/muscle","permalink":"/mikan-docs/references/mod/rig/muscle","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"rig.jiggle","permalink":"/mikan-docs/references/mod/rig/jiggle"},"next":{"title":"rig.path","permalink":"/mikan-docs/references/mod/rig/path"}}');var i=s(4848),t=s(8453);const o={},l="rig.muscle",d={},c=[{value:"Options",id:"options",level:2},{value:"Example",id:"example",level:2}];function h(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rigmuscle",children:"rig.muscle"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Builds a muscle rig that stretches, squashes, and shears between two targets."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This modifier creates a fake muscle rig that connects two target nodes and deforms one or more constrained nodes with stretch, squash, and shear behavior."}),"\n",(0,i.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nodes"})})," (",(0,i.jsx)(n.em,{children:"list[node]"}),", optional): Nodes to be driven by the muscle rig."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"targets"})})," (",(0,i.jsx)(n.em,{children:"list[node]"}),"): Exactly two nodes that serve as the start and end of the muscle (like tendons)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"parent"})})," (",(0,i.jsx)(n.em,{children:"node"}),", optional): Node under which the muscle rig will be parented. Defaults to the parent of the first node in ",(0,i.jsx)(n.code,{children:"nodes"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"hook"})})," (",(0,i.jsx)(n.em,{children:"bool"}),", default: ",(0,i.jsx)(n.code,{children:"false"}),"): If enabled, connects the muscle output to the driven nodes via matrix constraints instead of parenting."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"weight"})})," (",(0,i.jsx)(n.em,{children:"float"}),", optional, default: ",(0,i.jsx)(n.code,{children:"0.0"}),", min: ",(0,i.jsx)(n.code,{children:"0"}),", max: ",(0,i.jsx)(n.code,{children:"1"}),"): Switch weight for blending the hook behavior."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"orient"})})," (",(0,i.jsx)(n.em,{children:"bool"}),", default: ",(0,i.jsx)(n.code,{children:"true"}),"): Whether the tendon rig drives orientation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"scale"})})," (",(0,i.jsx)(n.em,{children:"bool"}),", default: ",(0,i.jsx)(n.code,{children:"true"}),"): Whether the tendon rig drives scale."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"stretch"})})," (",(0,i.jsx)(n.em,{children:"float"}),", optional, default: ",(0,i.jsx)(n.code,{children:"1.0"}),", min: ",(0,i.jsx)(n.code,{children:"0"}),", max: ",(0,i.jsx)(n.code,{children:"1"}),"): Blending value for the stretch behavior."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"squash"})})," (",(0,i.jsx)(n.em,{children:"float"}),", optional, default: ",(0,i.jsx)(n.code,{children:"0.0"}),", min: ",(0,i.jsx)(n.code,{children:"0"}),", max: ",(0,i.jsx)(n.code,{children:"1"}),"): Blending value for the squash behavior."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"shear"})})," (",(0,i.jsx)(n.em,{children:"float"}),", optional, default: ",(0,i.jsx)(n.code,{children:"1.0"}),", min: ",(0,i.jsx)(n.code,{children:"0"}),", max: ",(0,i.jsx)(n.code,{children:"1"}),"): Blending value for the shear behavior."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"name"})})," (",(0,i.jsx)(n.em,{children:"str"}),", optional): Name used for the muscle rig. If not set, defaults to a combination of the target names."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yml",children:"rig.muscle:\n  nodes:\n    - eyebrow_mid::roots.0\n    - eyebrow_crease::roots.0\n  targets:\n    - eyebrow.R::skin.0\n    - eyebrow.L::skin.0\n  orient: false\n  name: eyebrow_mid\n"})})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(6540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);