"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1486],{168:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/skull_mid_tpl-aa9dccc40de1d5361c33092ea2b5022a.png"},463:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"guides/facial_rig/templates","title":"Template Hierarchy","description":"In this guide, we will build a facial rig based on skin joint deformation. This approach is generally more constrained than blendshape-based systems, but it offers significant advantages in terms of flexibility, robustness, and reusability. Historically, this type of setup has been well suited to television series production, where short schedules and","source":"@site/docs/guides/11-facial_rig/01-templates.md","sourceDirName":"guides/11-facial_rig","slug":"/guides/facial_rig/templates","permalink":"/mikan-docs/guides/facial_rig/templates","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/mikan-docs/guides/facial_rig/intro"},"next":{"title":"Adding Modifiers","permalink":"/mikan-docs/guides/facial_rig/modifiers"}}');var o=i(4848),r=i(8453);const t={},l="Template Hierarchy",a={},d=[{value:"Anchoring",id:"anchoring",level:2},{value:"Using a Group Module as a Facial Root",id:"using-a-group-module-as-a-facial-root",level:4},{value:"Creating the Facial Group Module",id:"creating-the-facial-group-module",level:4},{value:"Skull hierarchy",id:"skull-hierarchy",level:2},{value:"Lower face",id:"lower-face",level:2},{value:"Jaws Controls",id:"jaws-controls",level:3},{value:"Lips Deformation",id:"lips-deformation",level:3},{value:"Primary Lip Controls",id:"primary-lip-controls",level:4},{value:"Mouth Segmentation Controls",id:"mouth-segmentation-controls",level:4},{value:"Lip Tweak Controls",id:"lip-tweak-controls",level:4},{value:"Teeth and Tongue",id:"teeth-and-tongue",level:3},{value:"Mid face",id:"mid-face",level:2},{value:"Upper Face",id:"upper-face",level:2},{value:"Eye hierarchy",id:"eye-hierarchy",level:3},{value:"Eyeball and Scale Space",id:"eyeball-and-scale-space",level:3},{value:"Eyelids",id:"eyelids",level:3},{value:"Eyebrows",id:"eyebrows",level:3},{value:"Ears",id:"ears",level:3},{value:"Secondary offset layer",id:"secondary-offset-layer",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"template-hierarchy",children:"Template Hierarchy"})}),"\n",(0,o.jsx)(n.p,{children:"In this guide, we will build a facial rig based on skin joint deformation. This approach is generally more constrained than blendshape-based systems, but it offers significant advantages in terms of flexibility, robustness, and reusability. Historically, this type of setup has been well suited to television series production, where short schedules and\nfrequent model iterations require rigs that can adapt quickly."}),"\n",(0,o.jsx)(n.p,{children:"Joint-based facial rigs are a proven solution. They have been used successfully on many productions and provide a solid, predictable foundation on which more complex behaviors can be layered. While they may require a bit more discipline in their construction, they tend to scale better across assets and episodes."}),"\n",(0,o.jsx)(n.p,{children:"In the following chapters, we will go through the core steps required to assemble such a system using Mikan:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Building a template module hierarchy for the facial rig and its animator interface"}),"\n",(0,o.jsx)(n.li,{children:"Adding logic through modifiers to create the actual functioning of the rig"}),"\n",(0,o.jsx)(n.li,{children:"Recording facial poses and linking them to the animator controls"}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"Even if you are more familiar with blendshape-based facial rigs, following this guide is still relevant. The type of system presented here is fully compatible with blendshapes, and many of the concepts apply regardless of the deformation method. While some sections may not need to be followed in detail, the parts related to pose connections and the animator\ninterface remain essential."})}),"\n",(0,o.jsx)(n.h2,{id:"anchoring",children:"Anchoring"}),"\n",(0,o.jsx)(n.p,{children:"Before building any facial structure, we first need to decide where the facial rig will attach to the rest of the character. It must be anchored to an existing part of the body hierarchy so that transforms, space, and evaluation remain consistent."}),"\n",(0,o.jsxs)(n.p,{children:["In our case, the body template is already set up. It consists of a simple biped, augmented with clothing modules and additional features. The head controller has already been created as part of the ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/neck/legacy",children:(0,o.jsx)(n.code,{children:"neck.legacy"})})," module, and it provides a natural attachment point for the facial rig."]}),"\n",(0,o.jsx)(n.p,{children:"This attachment point will serve as the root of the entire facial setup."}),"\n",(0,o.jsx)(n.h4,{id:"using-a-group-module-as-a-facial-root",children:"Using a Group Module as a Facial Root"}),"\n",(0,o.jsxs)(n.p,{children:["Rather than connecting facial modules directly to the head controller, we introduce an intermediate ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/core/group",children:(0,o.jsx)(n.code,{children:"core.group"})})," module. This group acts as the root container for the facial rig."]}),"\n",(0,o.jsx)(n.p,{children:"Group modules serve several purposes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"They provide a clean structural boundary for a rig subsystem"}),"\n",(0,o.jsx)(n.li,{children:"They allow all facial controllers to be selected at once"}),"\n",(0,o.jsx)(n.li,{children:"They help organize the animator interface hierarchy"}),"\n",(0,o.jsxs)(n.li,{children:["They are used by animator tools that operate on ",(0,o.jsx)(n.a,{href:"/mikan-docs/usage/controllers",children:"controller groups"})," (mirror, select, key...)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In practice, this makes the group module an essential building block for both rig organization and animator workflow, even if it does not introduce any deformation or logic by itself."}),"\n",(0,o.jsx)(n.h4,{id:"creating-the-facial-group-module",children:"Creating the Facial Group Module"}),"\n",(0,o.jsx)(n.p,{children:"To set up the facial template:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Select the head hook output of the ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/neck/legacy",children:(0,o.jsx)(n.code,{children:"neck.legacy"})})," module"]}),"\n",(0,o.jsxs)(n.li,{children:["Add a ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/core/group",children:(0,o.jsx)(n.code,{children:"core.group"})})," module at this connection point"]}),"\n",(0,o.jsxs)(n.li,{children:["Name the group module ",(0,o.jsx)(n.code,{children:"face"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"add group",src:i(7720).A+"",width:"296",height:"256"})}),"\n",(0,o.jsx)(n.p,{children:"This face group now becomes the root of the facial rig hierarchy. All subsequent facial modules and controls will be created under this group, ensuring that the facial system remains clearly organized, easy to manage, and properly integrated with the existing body rig."}),"\n",(0,o.jsx)(n.h2,{id:"skull-hierarchy",children:"Skull hierarchy"}),"\n",(0,o.jsxs)(n.p,{children:["The facial base starts with three parallel modules: ",(0,o.jsx)(n.code,{children:"skull"}),", ",(0,o.jsx)(n.code,{children:"skull_mid"}),", and ",(0,o.jsx)(n.code,{children:"skull_dn"}),". These form the foundation for controlling the overall shape and motion of the face. This separation gives you the flexibility to create subtle rotations, offsets, and squash/stretch without affecting unrelated areas."]}),"\n",(0,o.jsxs)(n.p,{children:["These modules are created using ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/core/joints",children:(0,o.jsx)(n.code,{children:"core.joints"})})," with the following option:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Type"}),": ",(0,o.jsx)(n.code,{children:"transform"}),(0,o.jsx)("br",{}),"\nEach element is parented in a simple hierarchy and scales accumulate."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Once they are placed, enable toggle shapes to edit the controller shapes, then repeat the operation for each module."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"skull template",src:i(3212).A+"",width:"1200",height:"590"})}),"\n",(0,o.jsx)(n.h2,{id:"lower-face",children:"Lower face"}),"\n",(0,o.jsx)(n.h3,{id:"jaws-controls",children:"Jaws Controls"}),"\n",(0,o.jsxs)(n.p,{children:["Next, we add two modules to open the mouth: ",(0,o.jsx)(n.code,{children:"jaw"})," and ",(0,o.jsx)(n.code,{children:"jaw_up"}),", parented under ",(0,o.jsx)(n.code,{children:"skull_dn"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["These modules are created using ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/core/bones",children:(0,o.jsx)(n.code,{children:"core.bones"})}),", which generate an FK-style joint segment. The following options are used:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Rotate order"}),": ",(0,o.jsx)(n.code,{children:"zxy"}),(0,o.jsx)("br",{}),"\nThis reduces the risk of gimbal issues during jaw rotation."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"}),(0,o.jsx)("br",{}),"\nThis anticipates the creation of facial poses related to mouth animation."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/core/bones",children:(0,o.jsx)(n.code,{children:"core.bones"})})," module is used here primarily to create a visible joint segment. This is especially useful later during skin binding, both for clarity and for selecting the appropriate skin joints. Beyond that, these controls do not require complex orientation behavior."]}),"\n",(0,o.jsx)(n.p,{children:"In most cases, the jaw controllers can remain in world orientation rather than being explicitly oriented along the bone. This generally results in simpler and more predictable manipulation, although the exact setup may vary depending on personal or production preferences."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"jaw template",src:i(526).A+"",width:"1200",height:"575"})}),"\n",(0,o.jsx)(n.h3,{id:"lips-deformation",children:"Lips Deformation"}),"\n",(0,o.jsxs)(n.p,{children:["We start by creating a global ",(0,o.jsx)(n.code,{children:"mouth"})," controller. This controller acts as the top-level control for the entire mouth system and is used to apply broad transformations affecting all mouth and lip elements at once."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"mouth"})," controller is created using a ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/core/joints",children:(0,o.jsx)(n.code,{children:"core.joints"})})," module, parented under ",(0,o.jsx)(n.code,{children:"skull_dn"}),"."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Type"}),": ",(0,o.jsx)(n.code,{children:"transform"}),(0,o.jsx)("br",{}),"\nGlobal controllers are expected to propagate scale in a simple and predictable way. Using a transform-based setup ensures clean scale transmission across the mouth system."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Next, under ",(0,o.jsx)(n.code,{children:"skull_dn"}),", we create a ",(0,o.jsx)(n.code,{children:"lips"})," group. Unlike the ",(0,o.jsx)(n.code,{children:"mouth"})," controller, this group is not meant to drive deformation directly. Its role is organizational."]}),"\n",(0,o.jsxs)(n.p,{children:["The mouth system is built in three conceptual layers, with the global ",(0,o.jsx)(n.code,{children:"mouth"})," controller sitting above them."]}),"\n",(0,o.jsx)(n.h4,{id:"primary-lip-controls",children:"Primary Lip Controls"}),"\n",(0,o.jsxs)(n.p,{children:["Inside the ",(0,o.jsx)(n.code,{children:"lips"})," group, we add the main directional controls using ",(0,o.jsx)(n.a,{href:"/mikan-docs/references/tpl/core/joints",children:(0,o.jsx)(n.code,{children:"core.joints"})})," modules:"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"lip_up"})," and ",(0,o.jsx)(n.code,{children:"lip_dn"}),". These define the overall motion of the upper and lower lips."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Type"}),": ",(0,o.jsx)(n.code,{children:"transform"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"lips_corner"}),". This controller drives the corners of the mouth."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Flip orient"}),": ",(0,o.jsx)(n.code,{children:"on"}),(0,o.jsx)("br",{}),"\nFor symmetric lip controls, translation consistency is preferred over rotational symmetry. Enabling flip orient ensures predictable behavior when manipulating paired controllers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Type"}),": ",(0,o.jsx)(n.code,{children:"transform"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These controllers provide broad, readable motion and will later propagate their influence to more localized controls."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"At this stage, none of these controls are connected to deformation logic. The goal here is to define the animator-facing structure first. All mechanical connections and behavior will be implemented in the next chapter."})}),"\n",(0,o.jsx)(n.h4,{id:"mouth-segmentation-controls",children:"Mouth Segmentation Controls"}),"\n",(0,o.jsxs)(n.p,{children:["We then add a set of mouth segmentation controllers using ",(0,o.jsx)(n.code,{children:"core.joints"})," modules:"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"mouth1_up"}),", ",(0,o.jsx)(n.code,{children:"mouth2_up"}),", ",(0,o.jsx)(n.code,{children:"mouth3_up"}),", ",(0,o.jsx)(n.code,{children:"mouth4"}),", ",(0,o.jsx)(n.code,{children:"mouth3_dn"}),", ",(0,o.jsx)(n.code,{children:"mouth2_dn"}),", ",(0,o.jsx)(n.code,{children:"mouth1_dn"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsxs)(n.p,{children:["For the lip zone controllers, we\u2019ve set up a default of ",(0,o.jsx)(n.code,{children:"mouth1"})," > ",(0,o.jsx)(n.code,{children:"mouth4"})," for segmentation. This provides a minimal setup that works for most cases."]}),(0,o.jsx)(n.p,{children:"You can of course add more tweakers depending on the character\u2019s morphology and production requirements. If you choose to extend the number of lip controllers, remember to adapt the modifiers accordingly to ensure correct propagation of motion and poses."}),(0,o.jsx)(n.p,{children:"In our demo character, we added a few extra tweakers to achieve more refined deformations. You\u2019ll see how it works in practice."})]}),"\n",(0,o.jsx)(n.p,{children:"All of these controllers share the following options:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Flip orient"}),": ",(0,o.jsx)(n.code,{children:"on"}),(0,o.jsx)("br",{}),"\nAgain, this favors consistent translation behavior when manipulating symmetric controller pairs."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For ",(0,o.jsx)(n.code,{children:"mouth2"}),", ",(0,o.jsx)(n.code,{children:"mouth3"}),", and ",(0,o.jsx)(n.code,{children:"mouth4"}),", we also enable:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Branches"}),": ",(0,o.jsx)(n.code,{children:"[L, R]"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These controls split the mouth in a circular fashion and are used to shape the mouth globally. They are the primary layer for creating expressions such as smiles, frowns, stretches, and compressions."}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsx)(n.p,{children:"Orientation and Position Matter!"}),(0,o.jsx)(n.p,{children:"Take care when placing these template joints. Both the orientation and initial position of each joint are critical: rotations and scales applied to these controllers will be used for facial poses, and accurate positioning is essential to achieve smooth lip roll in/out operations later."}),(0,o.jsx)(n.p,{children:"Make sure the joints are aligned logically along the lip curve and follow the natural deformation flow."}),(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"lip tweakers orientation",src:i(5547).A+"",width:"776",height:"367"})})]}),"\n",(0,o.jsx)(n.h4,{id:"lip-tweak-controls",children:"Lip Tweak Controls"}),"\n",(0,o.jsx)(n.p,{children:"For each mouth segmentation controller, we create a corresponding lip tweak controller. Each lip controller is parented to its respective mouth segmentation controller and positioned at the same location."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"lip1_up"}),", ",(0,o.jsx)(n.code,{children:"lip2_up"}),", ",(0,o.jsx)(n.code,{children:"lip3_up"}),", ",(0,o.jsx)(n.code,{children:"lip4"}),", ",(0,o.jsx)(n.code,{children:"lip3_dn"}),", ",(0,o.jsx)(n.code,{children:"lip2_dn"}),", ",(0,o.jsx)(n.code,{children:"lip1_dn"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Parent scale"}),": ",(0,o.jsx)(n.code,{children:"on"}),(0,o.jsx)("br",{}),"\nThis allows lip controls to inherit scale from the mouth segmentation layer and can also be exploited for animation-specific behaviors."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Flip orient"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"They are dedicated to lip-only deformation and are primarily used for skinning and detailed effects such as lip roll. This separation allows precise control over lip behavior while keeping the overall mouth shaping clean and manageable."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"lips template",src:i(4699).A+"",width:"1200",height:"531"})}),"\n",(0,o.jsx)(n.h3,{id:"teeth-and-tongue",children:"Teeth and Tongue"}),"\n",(0,o.jsxs)(n.p,{children:["Under ",(0,o.jsx)(n.code,{children:"jaw"}),", we first create the lower teeth controllers using ",(0,o.jsx)(n.code,{children:"core.joints"}),".\nThe same setup will be mirrored for the upper teeth under ",(0,o.jsx)(n.code,{children:"jaw_up"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"We create the following hierarchy:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"teeth_dn"})," parented directly under ",(0,o.jsx)(n.code,{children:"jaw"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"teeth_tip_dn"})," child of ",(0,o.jsx)(n.code,{children:"teeth_dn"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"teeth_bend_dn"})," positioned at the side, near the root of the last molar"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"teeth_bend_tip_dn"})," child of ",(0,o.jsx)(n.code,{children:"teeth_bend_dn"}),", placed on the edge of the corresponding teeth"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The lower teeth controllers act like a lattice parented to the jaw. Animators can offset, rotate, or scale individual teeth segments independently, without affecting jaw motion directly. This provides fine control for teeth deformation while keeping the overall motion predictable."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"teeth_dn"})," and ",(0,o.jsx)(n.code,{children:"teeth_up"})," remain directly under their respective jaws without repositioning. This ensures that jaw rotation can be used to drive teeth motion in offset."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"teeth_bend_*"})," controllers are placed at the back of the mouth at the root of the last molars."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"*_tip_*"})," controllers sit on the front edge of each tooth segment, giving additional control over the tips."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"teeth_bend"})," options:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Branches"}),": ",(0,o.jsx)(n.code,{children:"[L, R]"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Flip orient"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Parent scale"}),": ",(0,o.jsx)(n.code,{children:"on"}),(0,o.jsx)("br",{}),"\nThis will allow riggers to choose whether scale is transmitted along the sides of the dental rows"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"and for the tips:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Type"}),": ",(0,o.jsx)(n.code,{children:"transform"}),(0,o.jsx)("br",{}),"\nSimple enough for translation/rotation without complex hierarchy"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Next, we create the tongue chain."}),"\n",(0,o.jsxs)(n.p,{children:["To maintain control over the global scale and orientation of the tongue, we first add a ",(0,o.jsx)(n.code,{children:"core.joints"})," controller: ",(0,o.jsx)(n.code,{children:"tongue_base"})," parented under ",(0,o.jsx)(n.code,{children:"teeth_dn"}),". This will allow neutral orientation and direct control over tongue scale."]}),"\n",(0,o.jsxs)(n.p,{children:["We then create a ",(0,o.jsx)(n.code,{children:"core.bones"})," chain for the ",(0,o.jsx)(n.code,{children:"tongue"})," with 3 joints by default (more can be added if needed)"]}),"\n",(0,o.jsx)(n.p,{children:"Options for the tongue modules:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Do pose"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"And to auto-orient the chain:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Orient"}),": ",(0,o.jsx)(n.code,{children:"auto"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Up axis"}),": ",(0,o.jsx)(n.code,{children:"x"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Up dir"}),": ",(0,o.jsx)(n.code,{children:"+x"}),(0,o.jsx)("br",{}),"\nExplicitly setting the direction ensures consistent rotation, especially important given the tongue\u2019s curved shape"]}),"\n"]}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsx)(n.p,{children:"Throughout the lower face, we\u2019ve added a variety of controllers that can be used to define facial poses and shapes."}),(0,o.jsx)(n.p,{children:"Don\u2019t hesitate to add additional elements if you feel more control is needed. For example, if you want finer control over the chin, you can create a new controller parented under the jaw."}),(0,o.jsx)(n.p,{children:"By following this approach, you have all the building blocks to construct the hierarchy that fits your production needs. This philosophy applies not only to the lower face but also to other areas of the rig: start with a solid base, then add controllers as needed to give animators precise control over facial deformation."})]}),"\n",(0,o.jsx)(n.h2,{id:"mid-face",children:"Mid face"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"skull_mid"})," module is used as the connection layer between the upper and lower parts of the skull. Later, using modifiers, we will define how constraints propagate between ",(0,o.jsx)(n.code,{children:"skull"}),", ",(0,o.jsx)(n.code,{children:"skull_dn"}),", and the ",(0,o.jsx)(n.code,{children:"jaw"})," modules. This setup is especially useful for cartoon-style rigs, where a high level of flexibility is required to bend the head shape or manage\nsquash and stretch effects across the face."]}),"\n",(0,o.jsxs)(n.p,{children:["At this stage, however, we are not building that logic yet. Here, we focus on the elements that are parented under ",(0,o.jsx)(n.code,{children:"skull_mid"})," and act as simple offsets."]}),"\n",(0,o.jsx)(n.p,{children:"In practice, this mainly concerns the nose rig. Anything related to broader, surface-level deformations such as cheeks or facial volume will be handled later using a secondary skin layer, once the primary structure is in place."}),"\n",(0,o.jsx)(n.p,{children:"For now, we keep things intentionally simple. The goal is to add a few lightweight controllers that can be used later for posing and skin deformation, without introducing complex mechanics."}),"\n",(0,o.jsxs)(n.p,{children:["All modules in this section are created using ",(0,o.jsx)(n.code,{children:"core.joints"}),", which provides everything needed to drive skin joints and record poses."]}),"\n",(0,o.jsxs)(n.p,{children:["Under ",(0,o.jsx)(n.code,{children:"skull_mid"}),", you can add the following modules: ",(0,o.jsx)(n.code,{children:"nose"})," and ",(0,o.jsx)(n.code,{children:"nostril"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"The exact placement of these controllers depends on the type of deformation you want to give animators access to, as well as any specific needs you may have for facial poses later on. There is no single correct layout here, only informed choices."}),"\n",(0,o.jsx)(n.p,{children:"Recommended options, depending on your needs:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Type"}),": ",(0,o.jsx)(n.code,{children:"transform"}),(0,o.jsx)("br",{}),"\nUse joint only if you explicitly need scale to affect deformation."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Branches"}),": ",(0,o.jsx)(n.code,{children:"[L, R]"}),(0,o.jsx)("br",{}),"\nFor mirrored controls, such as nostrils."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"At this point, these modules act purely as offset controllers. They are not yet connected to the rest of the facial logic. All interactions and constraints involving skull_mid will be implemented later, once the full facial hierarchy is in place."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"skull mid template",src:i(168).A+"",width:"1400",height:"624"})}),"\n",(0,o.jsx)(n.h2,{id:"upper-face",children:"Upper Face"}),"\n",(0,o.jsx)(n.p,{children:"The upper face contains more moving parts than the previous sections. Here, we lay down the structural skeleton for eyes, eyelids, eyebrows, and ears. In this chapter, we focus primarily on the eye system, which requires a solid and carefully thought-out hierarchy."}),"\n",(0,o.jsx)(n.p,{children:"The eyes usually involve several interacting layers: deformation of the skull around the socket, animation of the eyeball itself, and deformation of the eyelids. The goal here is not to fully rig everything yet, but to establish a robust base structure that will support animation and deformation later on."}),"\n",(0,o.jsx)(n.h3,{id:"eye-hierarchy",children:"Eye hierarchy"}),"\n",(0,o.jsx)(n.p,{children:"We begin by creating a top-level controller that encapsulates the entire eye system. This controller allows animators to reposition the eye inside the skull without breaking the internal hierarchy."}),"\n",(0,o.jsxs)(n.p,{children:["Under skull, create a ",(0,o.jsx)(n.code,{children:"core.joints"})," module named ",(0,o.jsx)(n.code,{children:"eye_root"})," with the following options:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Branches"}),": ",(0,o.jsx)(n.code,{children:"[L, R]"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Flip orient"}),": ",(0,o.jsx)(n.code,{children:"on"}),(0,o.jsx)("br",{}),"\nTranslation consistency is generally preferred over rotation for symmetrical eye controls."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This controller should be placed at a strategic location. If you intend to use it for squash and stretch, it is recommended to position it at the base of the eye opening and orient it following the general curvature of the skull."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"eye root orient",src:i(4923).A+"",width:"480",height:"450"})}),"\n",(0,o.jsx)(n.p,{children:"The eye_root acts as a protective container for the entire eye rig and provides a clean offset layer for animation."}),"\n",(0,o.jsx)(n.h3,{id:"eyeball-and-scale-space",children:"Eyeball and Scale Space"}),"\n",(0,o.jsx)(n.p,{children:"In cartoon rigs, eyeballs often require non-uniform scaling. To support this while keeping rotations stable, we introduce a dedicated scale space."}),"\n",(0,o.jsxs)(n.p,{children:["First, create a ",(0,o.jsx)(n.code,{children:"core.xform"})," module named ",(0,o.jsx)(n.code,{children:"eye_socket"}),". This module defines a controlled scale space, typically matching the proportions coming from modeling."]}),"\n",(0,o.jsxs)(n.p,{children:["Under ",(0,o.jsx)(n.code,{children:"eye_socket"}),", add a ",(0,o.jsx)(n.code,{children:"core.joints"})," module named ",(0,o.jsx)(n.code,{children:"eyeball"}),". This controller will drive eye animation (look-at systems, poses, offsets, etc.). Special care must be taken to orient the eyeball correctly, especially if the eye is not aligned with the world axes or if it lives inside a non-uniformly scaled space."]}),"\n",(0,o.jsx)(n.p,{children:"Options for eyeball:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add nodes"}),": ",(0,o.jsx)(n.code,{children:"inf"}),(0,o.jsx)("br",{}),"\nAdds intermediate transforms that can later receive constraints with identity matrices."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Rotate order"}),": ",(0,o.jsx)(n.code,{children:"zxy"}),(0,o.jsx)("br",{}),"\nThis order allows the eye twist to remain animatable regardless of orientation, which is especially useful when connecting eye poses later on."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This hierarchy allows both the eyeball and the eyelids to rotate correctly inside a scaled space, which is critical for clean deformation."}),"\n",(0,o.jsx)(n.h3,{id:"eyelids",children:"Eyelids"}),"\n",(0,o.jsx)(n.p,{children:"In this guide, eyelids are driven using rotation-based controllers that deform the geometry through clusters. The structure is therefore built with rotation in mind."}),"\n",(0,o.jsxs)(n.p,{children:["All eyelid controllers are created using ",(0,o.jsx)(n.code,{children:"core.joints"})," and are parented directly under ",(0,o.jsx)(n.code,{children:"eye_socket"}),", with zeroed translations. This ensures they rotate cleanly around the eyeball center."]}),"\n",(0,o.jsx)(n.p,{children:"We create the following controllers:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"eyelid_up"}),", ",(0,o.jsx)(n.code,{children:"eyelid_dn"}),(0,o.jsx)("br",{}),"\nPrimary controllers for blinking."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"eyelid_bend_up"}),", ",(0,o.jsx)(n.code,{children:"eyelid_bend_dn"}),(0,o.jsx)("br",{}),"\nParented respectively under the main eyelid controllers, used to offset and shape blinks."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"eyelid_corner_ext"}),", ",(0,o.jsx)(n.code,{children:"eyelid_corner_int"}),(0,o.jsx)("br",{}),"\nControls for the outer and inner corners of the eyelids."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"eyelids_socket_up"}),", ",(0,o.jsx)(n.code,{children:"eyelids_socket_dn"}),(0,o.jsx)("br",{}),"\nUsed to adjust the position of the eyelid crease."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"For all eyelid controllers, use:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Rotate order"}),": ",(0,o.jsx)(n.code,{children:"yzx"}),(0,o.jsx)("br",{}),"\nThis order is optimized for the vertical movement of the blink."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"At this stage, these controllers are not yet connected to deformation logic. They simply establish the control structure that will later be wired through modifiers and skinning."}),"\n",(0,o.jsx)(n.h3,{id:"eyebrows",children:"Eyebrows"}),"\n",(0,o.jsx)(n.p,{children:"The last elements to set up in the upper face are the eyebrows. In this guide, we deliberately keep the setup simple: a global controller combined with a small set of tweak controls."}),"\n",(0,o.jsxs)(n.p,{children:["Start by adding a ",(0,o.jsx)(n.code,{children:"core.joints"})," module named ",(0,o.jsx)(n.code,{children:"eyebrow_base"}),". Place it slightly toward the inside of the face, taking into account the rotations you may want to perform later. Its position should anticipate the range of motion required for eyebrow expressions."]}),"\n",(0,o.jsxs)(n.p,{children:["Next, we add the tweak controllers. While eyebrows are often built using fully independent controllers, here we can still rely on ",(0,o.jsx)(n.code,{children:"core.joints"}),". This allows us to create all eyebrow controls in a single module and separate them using an option."]}),"\n",(0,o.jsxs)(n.p,{children:["Create a chain of 3 or 4 joints named ",(0,o.jsx)(n.code,{children:"eyebrow"})," with the following options:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Unchain"}),": ",(0,o.jsx)(n.code,{children:"on"}),(0,o.jsx)("br",{}),"\nSeparates the joints into independent tweak controllers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Flip orient"}),": ",(0,o.jsx)(n.code,{children:"on"}),(0,o.jsx)("br",{}),"\nFavors consistent translation for symmetrical manipulation."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This setup provides enough control to shape eyebrow expressions while keeping the hierarchy lightweight and easy to extend if needed."}),"\n",(0,o.jsx)(n.h3,{id:"ears",children:"Ears"}),"\n",(0,o.jsx)(n.p,{children:"Ears follow a structure similar to the tongue, with a clear separation between a global control and a deformation chain."}),"\n",(0,o.jsxs)(n.p,{children:["First, create a base controller for the ear using ",(0,o.jsx)(n.code,{children:"core.joints"})," named ",(0,o.jsx)(n.code,{children:"ear_base"}),". Unlike other facial elements, the pivot of this controller can be placed slightly inside the head. This allows the ear to rotate or slide along the skull, which can produce useful secondary motion if the character design allows it."]}),"\n",(0,o.jsxs)(n.p,{children:["Then, add a deformation chain using ",(0,o.jsx)(n.code,{children:"core.bones"})," named ",(0,o.jsx)(n.code,{children:"ear"}),". The number of joints depends entirely on the character\u2019s morphology. For human characters, one or two joints are usually enough."]}),"\n",(0,o.jsx)(n.p,{children:"At this stage, option choices are mostly left open. You should select what best fits your needs, as the guide does not impose a strict setup for ear deformation."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"eyes template",src:i(482).A+"",width:"1400",height:"619"})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"Controller shapes and visual design are not covered in this guide. You will need to define colors and shapes that make sense for animators. A common convention is to visually distinguish global controllers from tweak controls. Curved shapes often suggest rotational behavior, while angular shapes can indicate translation. How far you take this is entirely up\nto you."})}),"\n",(0,o.jsx)(n.h2,{id:"secondary-offset-layer",children:"Secondary offset layer"}),"\n",(0,o.jsx)(n.p,{children:"In this section, we add a secondary offset layer dedicated to skin deformation, primarily for the cheek area. These controllers are used to add localized surface detail on top of the main facial rig. This approach allows you to sculpt subtle deformations such as cheek compression, sliding, and secondary motion, without overloading the primary expression\ncontrols or compromising their readability."}),"\n",(0,o.jsxs)(n.p,{children:["We start by creating a ",(0,o.jsx)(n.code,{children:"core.group"})," module named ",(0,o.jsx)(n.code,{children:"cheeks"}),", parented directly under ",(0,o.jsx)(n.code,{children:"skull_mid"})," with the following option:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Branches"}),": ",(0,o.jsx)(n.code,{children:"[L, R]"}),(0,o.jsx)("br",{}),"\nUsing branches at the group level allows left and right cheek controls to be mirrored automatically. This avoids having to manage symmetry on a per-module basis and keeps the setup cleaner as the system grows."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Under the ",(0,o.jsx)(n.code,{children:"cheeks"})," group, we add several pairs of controllers using ",(0,o.jsx)(n.code,{children:"core.joints"}),". The exact number and placement depend on the character\u2019s morphology and the level of refinement required, but a small, well-placed set is usually sufficient."]}),"\n",(0,o.jsx)(n.p,{children:"Adjust the options as needed:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Flip orient"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Add pose node"}),": ",(0,o.jsx)(n.code,{children:"on"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"cheek template",src:i(3085).A+"",width:"1200",height:"530"})}),"\n",(0,o.jsx)(n.p,{children:"These controllers will later be constrained to the main facial rig through dedicated modifiers, allowing them to function as a true secondary skin layer. There are many valid ways to implement this kind of system, depending on how much influence you want these offsets to have over the final deformation."}),"\n",(0,o.jsx)(n.p,{children:"We will cover the required constraints and setup strategies in the next chapter, where this secondary layer will be fully integrated into the facial rig."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},482:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/eyes_tpl-3aef00084785aa94cba7284991a8a88a.png"},526:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/jaw_tpl-11384a823586d1476ce0667a861a6aed.png"},3085:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/cheeks_tpl-bff1b1f1f2e1df48851bd094ba891759.png"},3212:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/skull_tpls-7c693ea6b8b0c5ba68835151a50b3c01.png"},4699:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/lips_tpls-1b1afab3c200139570622c71aa4425ef.png"},4923:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/eye_root-821a42c9393e8ca329890660bef7559b.png"},5547:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/lips_orient-88a26de2388a8facd1e4a819c6148af6.png"},7720:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/add_group-d640ca424abed12881b4abd4777c7a1c.png"},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var s=i(6540);const o={},r=s.createContext(o);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);