"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[856],{5274:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>a,frontMatter:()=>c,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"references/mod/shape/channel","title":"shape.channel","description":"Aggregates and routes multiple plugs through an intermediate buffer node to a controller.","source":"@site/docs/references/mod/shape/channel.md","sourceDirName":"references/mod/shape","slug":"/references/mod/shape/channel","permalink":"/mikan-docs/references/mod/shape/channel","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"rig.rivet","permalink":"/mikan-docs/references/mod/rig/rivet"},"next":{"title":"phonemes","permalink":"/mikan-docs/references/mod/shape/phonemes"}}');var l=s(4848),r=s(8453);const c={},d="shape.channel",o={},t=[{value:"Options",id:"options",level:2},{value:"Example",id:"example",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"shapechannel",children:"shape.channel"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Aggregates and routes multiple plugs through an intermediate buffer node to a controller."}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"channel"}),' modifier is primarily designed to centralize and manage facial rig connections, similar in spirit to tools like the BCS plugin. It aggregates attributes ("plugs") from multiple source nodes and channels them into a single controller node, optionally through an intermediate buffer node.']}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"node"})})," (",(0,l.jsx)(n.em,{children:"node"}),", optional): The node on which intermediate buffer channels will be created."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"sources"})})," (",(0,l.jsx)(n.em,{children:"node"})," | ",(0,l.jsx)(n.em,{children:"list[node]"}),"): Nodes that contain the plugs to aggregate."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"target"})})," (",(0,l.jsx)(n.em,{children:"node"}),"): The controller node that will expose the unified channel plugs."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"shapes"})})," (",(0,l.jsx)(n.em,{children:"list[dict]"}),"): List of plug definitions to be connected and exposed on the target controller.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"<plug_name>"})})," (",(0,l.jsx)(n.em,{children:"dict"}),"): Configuration for the control plug.",(0,l.jsx)(n.br,{}),"\n","The modifier will scan all listed sources for each requested plug. If a matching plug is found, a connection will be made from the controller (target) to that plug.\nIf no matching plug is found, or if no applicable rule (like driven, combo, etc.) is provided, the plug will not be created on the controller.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"div"})})," (",(0,l.jsx)(n.em,{children:"str"})," | ",(0,l.jsx)(n.em,{children:"list[str]"}),", optional): Adds suffixes to plug names to search variants (e.g., ",(0,l.jsx)(n.code,{children:"[L, R]"})," makes ",(0,l.jsx)(n.code,{children:"m_smile_L"}),", ",(0,l.jsx)(n.code,{children:"m_smile_R"}),")."]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"type"})})," (",(0,l.jsx)(n.em,{children:"str"}),", default: ",(0,l.jsx)(n.code,{children:"float"}),"): Explicitly sets the plug type. Available: ",(0,l.jsx)(n.code,{children:"float"}),", ",(0,l.jsx)(n.code,{children:"int"}),", ",(0,l.jsx)(n.code,{children:"bool"}),", ",(0,l.jsx)(n.code,{children:"enum"}),", ",(0,l.jsx)(n.code,{children:"separator"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"default"})}),", ",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"dv"})})," (",(0,l.jsx)(n.em,{children:"float"}),", default: ",(0,l.jsx)(n.code,{children:"0"}),"): Default value for the plug on the controller."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"min"})}),", ",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"max"})})," (",(0,l.jsx)(n.em,{children:"float"}),", optional): Value bounds for the plug (applies to controller and buffer)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"enum"})})," (",(0,l.jsx)(n.em,{children:"list[str]"}),", optional): Overrides the enum list if ",(0,l.jsx)(n.code,{children:"type"})," is set to ",(0,l.jsx)(n.code,{children:"enum"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"driven"})})," (",(0,l.jsx)(n.em,{children:"dict"}),", optional): Allows blending of multiple source plugs into a single plug using animation curves."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"<plug_name>"})})," (",(0,l.jsx)(n.em,{children:"float"})," | ",(0,l.jsx)(n.em,{children:"dict"}),"): Defines the shape of the animation curve between parent and child plug.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"float"}),": Auto mode (e.g., ",(0,l.jsx)(n.code,{children:"m_smile: 1"})," clamps negative values)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"dict"}),": Full curve definition (",(0,l.jsx)(n.code,{children:"{0: 0, 1: 1, pre: linear, post: flat}"}),"). See ",(0,l.jsx)(n.a,{href:"../drive",children:"drive"})," for more details."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"sep"})})," (",(0,l.jsx)(n.em,{children:"bool"}),"): If true, defines a visual plug separator on the controller. Overrides other plug options."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"combo"})})," (",(0,l.jsx)(n.em,{children:"dict"}),"): Defines logic-driven plugs that trigger when combinations of parent plugs meet specified values.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"<plug_name>"})})," (",(0,l.jsx)(n.em,{children:"dict"}),"): New plug to connect based on logic.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"div"})})," (",(0,l.jsx)(n.em,{children:"str"})," | ",(0,l.jsx)(n.em,{children:"list[str]"}),", optional): Optional suffixes."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"drivers"})})," (",(0,l.jsx)(n.em,{children:"dict"}),"): Rules for driving logic:","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"<plug_name>"})})," (",(0,l.jsx)(n.em,{children:"float"})," | ",(0,l.jsx)(n.em,{children:"dict"}),"): Each must match the value for the effect to trigger.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"float"}),": Target value for activation."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"dict"}),": Custom curve definition. See ",(0,l.jsx)(n.a,{href:"../drive",children:"drive"})," for more details."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yml",children:"[mod]\nshape.channel:\n  sources:\n    - shp_face::node\n    - shp_lips::node\n  target: face_dn::ctrls.0\n  shapes:\n    mouth:\n      type: separator\n\n    m_emote:\n      div: [L, R]\n      driven:\n        m_smile: 1\n        m_frown: -1\n      min: -2\n      max: 2\n\n    m_stretch:\n      div: [L, R]\n      driven:\n        m_wide: {0: 0, 1: 1, pre: linear, post: linear}\n        m_narrow: {0: 0, 1: -1, pre: linear, post: flat}\n      min: -2\n      max: 2\n\n  combo:\n    m_wide_smile:\n      drivers:\n        m_wide: 1\n        m_smile: 1\n      div: [L, R]\n"})}),"\n",(0,l.jsx)(n.p,{children:"This setup:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Aggregates facial shape attributes from ",(0,l.jsx)(n.code,{children:"shp_face"})," and ",(0,l.jsx)(n.code,{children:"shp_lips"})]}),"\n",(0,l.jsxs)(n.li,{children:["Groups them under ",(0,l.jsx)(n.code,{children:"face_dn::ctrls.0"})]}),"\n",(0,l.jsxs)(n.li,{children:["Supports mirrored plugs via ",(0,l.jsx)(n.code,{children:"div"})]}),"\n",(0,l.jsxs)(n.li,{children:["Mixes values with ",(0,l.jsx)(n.code,{children:"driven"})]}),"\n",(0,l.jsxs)(n.li,{children:["Combines logic conditions with ",(0,l.jsx)(n.code,{children:"combo"})]}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>d});var i=s(6540);const l={},r=i.createContext(l);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);