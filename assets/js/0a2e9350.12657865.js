"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[4426],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(96540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},67343:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"developer/extending/template","title":"Authoring Templates","description":"Templates are the fundamental building blocks of a Mikan rig. They define modular components (e.g., an arm, a spine, or a locator) that Mikan assembles to create a complete character.","source":"@site/docs/developer/02-extending/01-template.md","sourceDirName":"developer/02-extending","slug":"/developer/extending/template","permalink":"/mikan-docs/developer/extending/template","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Architecture Overview","permalink":"/mikan-docs/developer/overview"},"next":{"title":"Authoring Modifiers","permalink":"/mikan-docs/developer/extending/mod"}}');var t=i(74848),r=i(28453);const l={},o="Authoring Templates",d={},c=[{value:"Anatomy of a Template",id:"anatomy-of-a-template",level:2},{value:"Connectivity and Hooks",id:"connectivity-and-hooks",level:3},{value:"File Structure &amp; Registration",id:"file-structure--registration",level:2},{value:"Directory Layout",id:"directory-layout",level:3},{value:"Loading the Module",id:"loading-the-module",level:3},{value:"Configuration Manifest (template.yml)",id:"configuration-manifest-templateyml",level:2},{value:"Metadata &amp; Inheritance",id:"metadata--inheritance",level:3},{value:"Naming Conventions (<code>names</code>)",id:"naming-conventions-names",level:3},{value:"Structure &amp; addressing",id:"structure--addressing",level:3},{value:"Parameters (<code>guides</code>, <code>opts</code>)",id:"parameters-guides-opts",level:3},{value:"Controllers Geometry (<code>shapes</code>)",id:"controllers-geometry-shapes",level:3},{value:"Logical Hierarchy (<code>hierarchy</code>)",id:"logical-hierarchy-hierarchy",level:3},{value:"Interface (<code>ui</code>)",id:"interface-ui",level:3},{value:"Example Configuration",id:"example-configuration",level:3},{value:"Python Implementation &amp; DCC Support",id:"python-implementation--dcc-support",level:2},{value:"The Guide Phase: <code>build_template()</code>",id:"the-guide-phase-build_template",level:3},{value:"Dynamic Renaming: <code>rename_template()</code>",id:"dynamic-renaming-rename_template",level:3},{value:"The Rig Phase: <code>build_rig()</code>",id:"the-rig-phase-build_rig",level:3},{value:"1. Fetching Data",id:"1-fetching-data",level:4},{value:"2. The Naming Engine",id:"2-the-naming-engine",level:4},{value:"3. Construction",id:"3-construction",level:4},{value:"4. Registration (The &quot;Binding&quot;)",id:"4-registration-the-binding",level:4},{value:"API Reference: <code>Template</code> Methods",id:"api-reference-template-methods",level:2},{value:"Helpers &amp; Libraries",id:"helpers--libraries",level:2},{value:"Maya cmdx (<code>mikan.maya.cmdx</code>)",id:"maya-cmdx-mikanmayacmdx",level:3},{value:"Rigging Helpers (<code>mikan.maya.lib.rig</code>)",id:"rigging-helpers-mikanmayalibrig",level:3},{value:"Complete Example",id:"complete-example",level:2}];function a(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"authoring-templates",children:"Authoring Templates"})}),"\n",(0,t.jsx)(n.p,{children:"Templates are the fundamental building blocks of a Mikan rig. They define modular components (e.g., an arm, a spine, or a locator) that Mikan assembles to create a complete character."}),"\n",(0,t.jsx)(n.p,{children:"A Template operates in two distinct phases:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Guide Phase"}),": A lightweight skeleton hierarchy used by the rigger to place pivots and define the controllers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Rig Phase"}),": The functional animation setup (controls, constraints, deformers) generated during the build process."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To create a new template module, you must establish a specific directory structure, define a configuration manifest, and implement the Python logic for your target DCC."}),"\n",(0,t.jsx)(n.h2,{id:"anatomy-of-a-template",children:"Anatomy of a Template"}),"\n",(0,t.jsx)(n.p,{children:"Before configuring a template, it is crucial to understand its structure within the scene (DCC)."}),"\n",(0,t.jsxs)(n.p,{children:["A Template instance is represented as a joint hierarchy identified by a unique ",(0,t.jsx)(n.strong,{children:"Root Node"}),". Mikan traverses the full scene hierarchy to identify parent-child relationships between these instances."]}),"\n",(0,t.jsx)(n.p,{children:"Structurally, a Template consists of:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Root"}),": The top-most joint of the template. It holds all the metadata required by Mikan to identify the module type and its settings."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Hierarchy"}),": A chain of child joints defining the structure. Other templates can be parented to any joint in this chain (not just the end)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Guide Shapes"}),": NURBS curves parented to the joints. These visual cues serve as the blueprint for the shape of the final rig controllers.","\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"The Template API allows an instance to query its own hierarchy, identifying which joints belong to it versus which joints belong to a child template."})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"connectivity-and-hooks",children:"Connectivity and Hooks"}),"\n",(0,t.jsx)(n.p,{children:"A key feature of Mikan is flexible parenting. A child template can be attached to any joint of a parent template."}),"\n",(0,t.jsxs)(n.p,{children:["During the build process, every joint in a template creates a ",(0,t.jsx)(n.strong,{children:"Hook"}),". A Hook is an anchor point in the final rig where child modules attach their own rig logic."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example"}),": Consider an Arm Template containing a shoulder, elbow, and wrist."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The Arm hierarchy ends at the wrist joint."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Finger Templates"})," are parented directly to the Arm's wrist joint in the Guide."]}),"\n",(0,t.jsx)(n.li,{children:'During the build, the Arm module generates a "Wrist Hook".'}),"\n",(0,t.jsx)(n.li,{children:"The Finger modules automatically find this hook and attach their respective build logic to it."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"file-structure--registration",children:"File Structure & Registration"}),"\n",(0,t.jsxs)(n.p,{children:["To add a new template module, you simply need to create a directory within the ",(0,t.jsx)(n.code,{children:"mikan.templates.template"})," package. Mikan automatically scans this path on startup."]}),"\n",(0,t.jsx)(n.h3,{id:"directory-layout",children:"Directory Layout"}),"\n",(0,t.jsx)(n.p,{children:"The folder name serves as the unique ID of the module. To organize templates into categories (e.g., biped, prop, vehicle), you should place your module folder inside a category folder."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Standard Path"}),": ",(0,t.jsx)(n.code,{children:".../mikan/templates/template/[category]/[module_name]/"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Required Files"}),": Inside your module folder, you must provide:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"template.yml"}),": The configuration manifest."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[dcc].py"}),": The implementation logic (e.g., ",(0,t.jsx)(n.code,{children:"maya.py"}),", ",(0,t.jsx)(n.code,{children:"tangerine.py"}),")."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"mikan/\n\u2514\u2500\u2500 templates/\n    \u2514\u2500\u2500 template/\n        \u2514\u2500\u2500 arm/                 <-- Category (appears in UI)\n            \u2514\u2500\u2500 legacy/          <-- Module Name\n                \u251c\u2500\u2500 template.yml\n                \u251c\u2500\u2500 maya.py\n                \u2514\u2500\u2500 tangerine.py\n"})}),"\n",(0,t.jsx)(n.h3,{id:"loading-the-module",children:"Loading the Module"}),"\n",(0,t.jsx)(n.p,{children:"Once your files are created:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Restart your DCC or reload the Mikan Core."}),"\n",(0,t.jsx)(n.li,{children:"Open the Template Editor in the UI."}),"\n",(0,t.jsx)(n.li,{children:"Your module will appear in the defined category"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The module name used in code will be derived from the folder names. For the example above, the template ID would be ",(0,t.jsx)(n.code,{children:"category.name"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-manifest-templateyml",children:"Configuration Manifest (template.yml)"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"template.yml"})," file acts as the manifest for your module. It defines how Mikan presents the template in the UI, its default parameters, its inheritance logic, and crucially, how it maps physical joints to logical tags."]}),"\n",(0,t.jsx)(n.p,{children:"Below is a detailed breakdown of the available keys."}),"\n",(0,t.jsx)(n.h3,{id:"metadata--inheritance",children:"Metadata & Inheritance"}),"\n",(0,t.jsx)(n.p,{children:"Basic information to identify the template in the Mikan ecosystem."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"name"})}),': The default ID string for a new instance of this template (e.g., "arm", "spine").']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"desc"})}),": A short description displayed as a tooltip in the UI."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"help"})}),": A URL pointing to the full documentation for this module."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"base"})}),": Defines inheritance. The Python class for this template will inherit from the specified base class in addition to the standard DCC Template class.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Example"}),": ",(0,t.jsx)(n.code,{children:"base: _common.limb"})," (inherits methods from a generic limb module)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"naming-conventions-names",children:["Naming Conventions (",(0,t.jsx)(n.code,{children:"names"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"names"})})," key is a dictionary that allows you to define default naming suffixes for specific parts of the rig. These are logical keys, not final names. They provide a default value that users can override in the UI if they have specific naming charts."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Key"}),": The internal ID used in your Python code (e.g., ",(0,t.jsx)(n.code,{children:"cog"}),", ",(0,t.jsx)(n.code,{children:"limb1"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Value"}),": The default string suffix that will appear in the final node name."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"structure--addressing",children:"Structure & addressing"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"structure"})})," key is a dictionary (",(0,t.jsx)(n.code,{children:"tag: address"}),") that maps logical names (tags) to specific joints in the Guide skeleton."]}),"\n",(0,t.jsx)(n.p,{children:"Tagging Strategy:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Relative Depth"}),": You define the location based on hierarchy depth relative to the root.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"."})," : The Template Root joint."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"/1"})," : The immediate child of the Root."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"/2"})," : The child of the child, etc."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Explicit Tagging"}),": If no address is specified, Mikan searches for a joint that was explicitly tagged during the ",(0,t.jsx)(n.code,{children:"build_template()"})," Python procedure."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Important Constraint",type:"warning",children:(0,t.jsxs)(n.p,{children:['You cannot rely on sibling order (e.g., "the second child of X"). Scene formats like Alembic (',(0,t.jsx)(n.code,{children:".abc"}),") do not guarantee child order preservation. Always use specific branches or explicit tags to ensure correct retrieval."]})}),"\n",(0,t.jsxs)(n.h3,{id:"parameters-guides-opts",children:["Parameters (",(0,t.jsx)(n.code,{children:"guides"}),", ",(0,t.jsx)(n.code,{children:"opts"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Defines the editable attributes exposed in the UI."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"guides"})}),": Options affecting the ",(0,t.jsx)(n.strong,{children:"Guide Phase"})," (e.g., initial positions, joint counts)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"opts"})}),": Options affecting the ",(0,t.jsx)(n.strong,{children:"Rig Phase"})," (e.g., IK/FK, spacer types)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Common properties for both:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"}),": The default value. Determining the type (int ",(0,t.jsx)(n.code,{children:"1"}),", float ",(0,t.jsx)(n.code,{children:"1.0"}),", bool ",(0,t.jsx)(n.code,{children:"on/off"}),", string)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"min"}),"/",(0,t.jsx)(n.code,{children:"max"}),": Range clamps for UI sliders."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"enum"}),": A list of strings or a dict (",(0,t.jsx)(n.code,{children:"int: key"}),") for dropdown menus."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"help"}),": Tooltip description."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"yaml"}),": (Boolean) If ",(0,t.jsx)(n.code,{children:"true"}),", the value is parsed as YAML data (useful for list-type options)."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"controllers-geometry-shapes",children:["Controllers Geometry (",(0,t.jsx)(n.code,{children:"shapes"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["A dictionary (",(0,t.jsx)(n.code,{children:"id: dict"}),") defining the default controller shapes. The ",(0,t.jsx)(n.code,{children:"id"})," must match the controller ID generated during the rig build (e.g., if the build generates ",(0,t.jsx)(n.code,{children:"arm.L::ctrls.1"}),", use ",(0,t.jsx)(n.code,{children:"ctrls.1"}),")."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"parent"}),': The node that "holds" this shape curve in the Guide. ',(0,t.jsxs)(n.strong,{children:["Must refer to a tag defined in ",(0,t.jsx)(n.code,{children:"structure"})]}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"shape"}),": The shape ID from the internal database (",(0,t.jsx)(n.code,{children:"mikan.templates.shapes"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"color"}),": CSS-style color code (e.g., ",(0,t.jsx)(n.code,{children:"red"}),", ",(0,t.jsx)(n.code,{children:"#F00"}),", ",(0,t.jsx)(n.code,{children:"#FF0000"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"size"}),": Scale multiplier (default: 1)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"aim"}),"/",(0,t.jsx)(n.code,{children:"up"}),": Entry point structure for the shape rig (for auto-orientation)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"up_axis"}),": Axis used for the aim constraint."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"logical-hierarchy-hierarchy",children:["Logical Hierarchy (",(0,t.jsx)(n.code,{children:"hierarchy"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["This is a critical section. It describes the ",(0,t.jsx)(n.strong,{children:"Virtual Hierarchy"})," of the rig elements (Controllers and Skin Joints). This abstraction allows Mikan to reconstruct the skeleton logic (pickwalking, export) regardless of the complex physical constraints in the scene."]}),"\n",(0,t.jsx)(n.p,{children:"You typically define two main groups here: one for controllers and one for skin joints."}),"\n",(0,t.jsx)(n.p,{children:"Key Properties:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"root"}),": (Boolean) Declares if this node is a starting point of the local hierarchy.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"on"}),": This node will look for the parent template's hook to attach itself."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"off"})," (by default): This node expects a local ",(0,t.jsx)(n.code,{children:"parent"})," to be defined."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"parent"}),": Defines the internal parent within the ",(0,t.jsx)(n.em,{children:"current"})," template.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Value"}),": The ID of another node defined in this hierarchy section (e.g., ",(0,t.jsx)(n.code,{children:"ctrls.limb1"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hook"}),": Defines that this Rig Node acts as the anchor for a specific Structural Tag.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Value"}),": A tag from the ",(0,t.jsx)(n.code,{children:"structure"})," section."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Behavior"}),": If a child template is attached to the tag ",(0,t.jsx)(n.code,{children:"limb1"})," in the guide, its rig root will be automatically parented to this node (",(0,t.jsx)(n.code,{children:"ctrls.limb1"}),") in the final rig."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"chain"}),": (Boolean) If the ID refers to a list of nodes, ",(0,t.jsx)(n.code,{children:"chain: on"})," creates a serial hierarchy (0 -> 1 -> 2 -> ...)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"opts"}),": conditional overrides. A dictionary allowing you to change ",(0,t.jsx)(n.code,{children:"root"}),", ",(0,t.jsx)(n.code,{children:"hook"}),", or ",(0,t.jsx)(n.code,{children:"parent"})," logic based on a rig option (defined in ",(0,t.jsx)(n.code,{children:"opts"}),").","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Format"}),": ",(0,t.jsx)(n.code,{children:"option_name: override_dict"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Usage"}),": Useful if a boolean option (like ",(0,t.jsx)(n.code,{children:"do_clavicle"}),") changes the parenting logic."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"interface-ui",children:["Interface (",(0,t.jsx)(n.code,{children:"ui"}),")"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"icon"}),": Filename of the icon for the Mikan Outliner. (see: ",(0,t.jsx)(n.code,{children:"mikan.core.ui.icons"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hooks"}),": Defines valid attachment points for child templates.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Format"}),": ",(0,t.jsx)(n.code,{children:"display_name: structure"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"These appear in the UI when building a new template on top of this one."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-configuration",children:"Example Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["Here is an example for a simplified ",(0,t.jsx)(n.strong,{children:"Arm"})," module."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# Example Snippet\nname: arm\ndesc: Basic biped arm\nbase: _common.limb\n\nnames:\n  clav: clavicle # If user leaves default, node becomes \"c_clavicle_L\" or \"sk_clavicle_R\", etc.\n  limb1: shoulder\n  limb2: elbow\n  limb3: wrist\n\n# 1. Map physical joints to logical tags\nstructure:\n  clavicle:      # Abstract tag for clavicle\n  limb1: .       # Abstract tag for the shoulder/arm root\n  limb2: /1      # 1st child\n  limb3: /2      # 2nd generation\n\n# 2. Options\nopts:\n  do_clavicle:\n    help: Enables the clavicle rig.\n    value: on    # Boolean option\n\n# 3. Rig Hierarchy Definition\nhierarchy:\n\n  # The Clavicle Controller\n  ctrls.clav:\n    root: on            # Attaches to the body (parent template)\n    hook: clavicle      # Exposes itself as the anchor for anything attached to 'clavicle'\n\n  # The Arm/Shoulder Controller\n  ctrls.shoulder:\n    root: on            # DEFAULT: Starts a new chain (attached to body)\n    hook: limb1         # Exposes itself as anchor for 'limb1'\n\n    # CONDITION: If the user enabled the 'do_clavicle' option\n    opts:\n      do_clavicle:\n        root: off       # It is no longer a root...\n        parent: ctrls.clav  # ...it becomes a child of the clavicle controller.\n\n# 4. UI Exposure\nui:\n  icon: limb\n  # Where can users attach a hand or prop?\n  hooks:\n    hand: limb3\n    elbow: limb2\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["Theoretical explanations can sometimes be abstract. The most effective way to master these configurations is to ",(0,t.jsxs)(n.strong,{children:["inspect the ",(0,t.jsx)(n.code,{children:"template.yml"})," files of existing Mikan modules"]}),"."]}),(0,t.jsxs)(n.p,{children:["Analyzing built-in modules (like ",(0,t.jsx)(n.code,{children:"legs.legacy"})," or ",(0,t.jsx)(n.code,{children:"spine.legacy"}),") will give you concrete examples of how ",(0,t.jsx)(n.code,{children:"hooks"}),", ",(0,t.jsx)(n.code,{children:"opts"})," overrides, and inheritance are used in production contexts."]})]}),"\n",(0,t.jsx)(n.h2,{id:"python-implementation--dcc-support",children:"Python Implementation & DCC Support"}),"\n",(0,t.jsxs)(n.p,{children:["Mikan is designed to be DCC-agnostic. While the configuration (",(0,t.jsx)(n.code,{children:"template.yml"}),") defines the ",(0,t.jsx)(n.em,{children:"what"}),", the Python logic defines the ",(0,t.jsx)(n.em,{children:"how"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"To support multiple softwares (Maya, Tangerine, Blender), the geometric construction logic is isolated in specific files. Mikan automatically loads the appropriate file at runtime based on the active environment."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Inheritance Pattern:"}),"\nThe API enforces a strict contract: method names and purposes remain identical across all platforms."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maya:"})," ",(0,t.jsx)(n.code,{children:"class Template(mikan.maya.core.Template):"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tangerine:"})," ",(0,t.jsx)(n.code,{children:"class Template(mikan.tangerine.core.Template):"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"You must override the following three methods to define the module's behavior:"}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The examples below use Maya syntax (",(0,t.jsx)(n.code,{children:"mx"}),", ",(0,t.jsx)(n.code,{children:"cmds"}),"), but the logic applies equally to Tangerine or Blender APIs."]})}),"\n",(0,t.jsxs)(n.h3,{id:"the-guide-phase-build_template",children:["The Guide Phase: ",(0,t.jsx)(n.code,{children:"build_template()"})]}),"\n",(0,t.jsx)(n.p,{children:"Called when the user instantiates the module. Your goal is to build the visual skeleton used by the rigger to place pivots and define the volume."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Responsibility:"})," Create joints/locators and position them."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Crucial Step:"})," Use ",(0,t.jsx)(n.code,{children:"self.set_template_id(node, 'tag')"})," to link the physical node to a logical tag defined in your YAML ",(0,t.jsx)(n.code,{children:"structure"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def build_template(self, data):\n    root = self.node  # The root node provided by Mikan\n\n    # 1. Create Nodes (DCC Specific)\n    with mx.DagModifier() as md:\n        # Create a joint under the root\n        hips = md.create_node(mx.tJoint, parent=root)\n\n    # 2. Set Default Position\n    hips['ty'] = 10.0\n\n    # 3. TAGGING (Universal API)\n    # Maps this specific node to the 'hips' tag defined in template.yml\n    self.set_template_id(hips, 'hips')\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"dynamic-renaming-rename_template",children:["Dynamic Renaming: ",(0,t.jsx)(n.code,{children:"rename_template()"})]}),"\n",(0,t.jsx)(n.p,{children:"Called when the user renames the module in the UI. You must update the names of the physical objects in the scene to match the new ID."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Helper:"})," Use ",(0,t.jsx)(n.code,{children:"self.get_structure('tag')"})," to retrieve nodes. ",(0,t.jsx)(n.strong,{children:"Never rely on string names"}),", as they may have changed or contain prefixes."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def rename_template(self):\n    # Iterate over tags defined in your structure\n    for tag in ['hips', 'spine1', 'spine2', 'tip']:\n\n        # Get the actual node object(s) associated with the tag\n        nodes = self.get_structure(tag)\n\n        if nodes:\n            # Generate the new name using Mikan's naming engine\n            new_name = self.get_name(tag)\n\n            # Apply rename (DCC specific)\n            nodes[0].rename('tpl_' + new_name)\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"the-rig-phase-build_rig",children:["The Rig Phase: ",(0,t.jsx)(n.code,{children:"build_rig()"})]}),"\n",(0,t.jsx)(n.p,{children:"The main execution logic called during the global build. This method reads the guide, processes options, creates the rig components (controls, constraints), and registers the output."}),"\n",(0,t.jsx)(n.p,{children:"This process consists of 4 key steps:"}),"\n",(0,t.jsx)(n.h4,{id:"1-fetching-data",children:"1. Fetching Data"}),"\n",(0,t.jsx)(n.p,{children:"Retrieve guide positions and user options before building."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def build_rig(self):\n    # 1. Get the Parent Hook (The node where this module attaches)\n    hook_node = self.hook\n\n    # 2. Get Guide Nodes (From the Guide Phase)\n    # Returns a list of nodes. We usually take the first one [0].\n    tpl_hips = self.get_structure('hips')[0]\n\n    # 3. Get User Options (Defined in YAML 'opts')\n    # Mikan handles type conversion (bool, float, int) automatically.\n    use_stretch = self.get_opt('stretch') \n"})}),"\n",(0,t.jsx)(n.h4,{id:"2-the-naming-engine",children:"2. The Naming Engine"}),"\n",(0,t.jsxs)(n.p,{children:["Mikan uses a modular naming strategy. You manually construct the final string by assembling a ",(0,t.jsx)(n.strong,{children:"Prefix"}),", a ",(0,t.jsx)(n.strong,{children:"Side"})," (node type), a ",(0,t.jsx)(n.strong,{children:"Core Name"})," (from config), and a ",(0,t.jsx)(n.strong,{children:"Suffix"})," (side/index)."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Suffix"})," (",(0,t.jsx)(n.code,{children:"get_branch_suffix"}),") Returns the current topological identifier (e.g., ",(0,t.jsx)(n.code,{children:"_L"}),", ",(0,t.jsx)(n.code,{children:"_R"}),", ",(0,t.jsx)(n.code,{children:"_01"}),"). Call this once at the start of your build."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Core Name"})," (",(0,t.jsx)(n.code,{children:"get_name"}),") Resolves a logical token (e.g., ",(0,t.jsx)(n.code,{children:"cog"}),") against the YAML ",(0,t.jsx)(n.code,{children:"names"})," registry and any UI overrides."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assembly"})," Concatenate these elements to create the final name."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def build_rig(self):\n    # ... \n\n    # 1. Get Suffix (Location)\n    n_end = self.get_branch_suffix()  # e.g. \"_L\"\n\n    # 2. Get Core Names (Semantic)\n    n_cog = self.get_name('cog')  # e.g. \"spine_cog\"\n\n    # 3. Assemble: Prefix + Core + Suffix\n\n    # Root (Technical Parent)\n    root_cog = mx.create_node(mx.tJoint, parent=hook, name='root_' + n_cog + n_end)\n\n    # Controller (Animatable)\n    c_cog = mx.create_node(mx.tJoint, parent=root_cog, name='c_' + n_cog + n_end)\n\n    # Skin Joint (Bind)\n    j_cog = mx.create_node(mx.tJoint, parent=c_cog, name='j_' + n_cog + n_end)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Standard Prefixes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"root_"}),": Zero group / Offset buffer"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"c_"}),": Controller"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"sk_"}),": Skinning joint"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-construction",children:"3. Construction"}),"\n",(0,t.jsx)(n.p,{children:"Use the DCC-specific API or Mikan Helpers (see below) to build your kinematic logic (IK handles, constraints, connections)."}),"\n",(0,t.jsx)(n.h4,{id:"4-registration-the-binding",children:'4. Registration (The "Binding")'}),"\n",(0,t.jsxs)(n.p,{children:["Once the nodes are built, you must register them. This step connects your Python objects to the ",(0,t.jsx)(n.code,{children:"hierarchy"})," IDs in the YAML."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"set_id(node, 'id')"}),": Maps a rig object to a hierarchy ID (e.g., ",(0,t.jsx)(n.code,{children:"ctrls.cog"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"set_hook(guide_node, rig_node, 'hook_id')"}),": Defines an attachment point for future child templates. (e.g., ",(0,t.jsx)(n.code,{children:"hooks.pelvis"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"    # --- Registration ---\n\n    # 1. Register Control\n    # Mikan will look at YAML 'shapes', find 'ctrls.cog', and draw the curve on 'c_cog'.\n    self.set_id(c_cog, 'ctrls.cog')\n    \n    # 2. Register Hook\n    # \"If a child module attaches to the 'pelvis' hook, parent it to the 's_pelvis' node.\"\n    self.set_hook(tpl_hips, s_pelvis, 'hooks.pelvis')\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Automatic Shapes",type:"info",children:(0,t.jsxs)(n.p,{children:["Do not write code to create controller curves. Mikan automatically draws shapes ",(0,t.jsx)(n.em,{children:"after"})," ",(0,t.jsx)(n.code,{children:"build_rig"})," finishes, based on the nodes you register here using ",(0,t.jsx)(n.code,{children:"set_id"}),"."]})}),"\n",(0,t.jsxs)(n.h2,{id:"api-reference-template-methods",children:["API Reference: ",(0,t.jsx)(n.code,{children:"Template"})," Methods"]}),"\n",(0,t.jsxs)(n.p,{children:["Summary of the essential methods available within your ",(0,t.jsx)(n.code,{children:"Template"})," class."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Category"}),(0,t.jsx)(n.th,{children:"Method"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Data Access"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"get_structure(tag)"})}),(0,t.jsx)(n.td,{children:"Returns list of Guide nodes linked to the tag."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"get_opt(key)"})}),(0,t.jsxs)(n.td,{children:["Returns value of a Rig Option (YAML ",(0,t.jsx)(n.code,{children:"opts"}),")."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Naming"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"get_name(token)"})}),(0,t.jsx)(n.td,{children:"Generates full name string (Module + Side + Token)."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"get_branch_suffix()"})}),(0,t.jsxs)(n.td,{children:["Returns current suffix (e.g., ",(0,t.jsx)(n.code,{children:"_L"}),", ",(0,t.jsx)(n.code,{children:"_01"}),")."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"get_side()"})}),(0,t.jsxs)(n.td,{children:["Returns side string (",(0,t.jsx)(n.code,{children:"L"}),", ",(0,t.jsx)(n.code,{children:"R"}),", ",(0,t.jsx)(n.code,{children:"C"}),")."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Registration"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"set_template_id(node, tag)"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"(Guide Phase)"})," Links physical node to YAML structure."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"set_id(node, id)"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"(Rig Phase)"})," Maps rig node to YAML hierarchy ID."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"set_hook(guide, rig, id)"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"(Rig Phase)"})," Registers attachment point for children."]})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"helpers--libraries",children:"Helpers & Libraries"}),"\n",(0,t.jsx)(n.p,{children:"To ensure consistency and speed up development, prioritize using Mikan's internal libraries over standard DCC commands."}),"\n",(0,t.jsxs)(n.h3,{id:"maya-cmdx-mikanmayacmdx",children:["Maya cmdx (",(0,t.jsx)(n.code,{children:"mikan.maya.cmdx"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["Aliased as ",(0,t.jsx)(n.code,{children:"mx"}),", this wrapper speeds up drastically the DAG manipulation."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mx.DagModifier()"}),": Context manager for clean node creation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"node['ty'] = 5"}),": Direct attribute access."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"rigging-helpers-mikanmayalibrig",children:["Rigging Helpers (",(0,t.jsx)(n.code,{children:"mikan.maya.lib.rig"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Contains high-level rigging logic to avoid boilerplate code."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"copy_transform(src, dst)"}),": Snaps position/rotation/scale."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"orient_joint(joint, aim, up)"}),": Robust joint orientation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"create_joints_on_curve(curve, count)"}),": Generates chains along NURBS."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"stretch_spline_ik(...)"}),": One-line setup for stretchy spline IKs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"fix_inverse_scale(chain)"}),": Automatically handles segment scale compensation."]}),"\n",(0,t.jsx)(n.li,{children:"..."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"TODO: Add a comprehensive example of a template implementation."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);