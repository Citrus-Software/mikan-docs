"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3938],{3279:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"references/mod/constraint","title":"constraint","description":"Creates a constraint between a target and a constrained node.","source":"@site/docs/references/mod/constraint.md","sourceDirName":"references/mod","slug":"/references/mod/constraint","permalink":"/mikan-docs/references/mod/constraint","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"connect","permalink":"/mikan-docs/references/mod/connect"},"next":{"title":"curve","permalink":"/mikan-docs/references/mod/curve"}}');var i=s(4848),t=s(8453);const c={},d="constraint",o={},l=[{value:"\u26a0\ufe0f Notes",id:"\ufe0f-notes",level:3},{value:"Options",id:"options",level:2},{value:"Output",id:"output",level:2},{value:"Example",id:"example",level:3}];function a(e){const n={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"constraint",children:"constraint"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Creates a constraint between a target and a constrained node."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This modifier supports common constraint types such as ",(0,i.jsx)(n.code,{children:"orient"}),", ",(0,i.jsx)(n.code,{children:"aim"}),", ",(0,i.jsx)(n.code,{children:"point"}),", ",(0,i.jsx)(n.code,{children:"parent"}),", and ",(0,i.jsx)(n.code,{children:"scale"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"It supports multiple targets and offers fine control over offsets, blending, and skipped channels."}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-notes",children:"\u26a0\ufe0f Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["For ",(0,i.jsx)(n.strong,{children:"aim constraints"}),", ",(0,i.jsx)(n.code,{children:"maintain_offset"})," is not currently supported in Tangerine when using ",(0,i.jsx)(n.code,{children:"up_object"})," or ",(0,i.jsx)(n.code,{children:"up_vector"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Blending is useful only if the constrained node does ",(0,i.jsx)(n.strong,{children:"not"})," already have its SRT attributes connected."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"node"})})," (",(0,i.jsx)(n.em,{children:"node"}),", optional): Node being constrained."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"target"})})," (",(0,i.jsx)(n.em,{children:"node"}),"): Main constraint driver."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"targets"})})," (",(0,i.jsx)(n.em,{children:"list[node]"}),"): Additional constraint drivers. If both ",(0,i.jsx)(n.code,{children:"target"})," and ",(0,i.jsx)(n.code,{children:"targets"})," are provided, they are combined."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"type"})})," (",(0,i.jsx)(n.em,{children:"str"}),"): Type of constraint. One of: ",(0,i.jsx)(n.code,{children:"orient"}),", ",(0,i.jsx)(n.code,{children:"aim"}),", ",(0,i.jsx)(n.code,{children:"point"}),", ",(0,i.jsx)(n.code,{children:"parent"}),", ",(0,i.jsx)(n.code,{children:"scale"})]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"weights"})})," (",(0,i.jsx)(n.em,{children:"list[float]"}),", optional): Weights per target. Defaults to ",(0,i.jsx)(n.code,{children:"1.0"})," for each."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"maintain_offset"})})," (",(0,i.jsx)(n.em,{children:"bool"}),", default: ",(0,i.jsx)(n.code,{children:"false"}),"): Maintains the current offset between target and node."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"blend"})})," (",(0,i.jsx)(n.em,{children:"bool"}),", default: ",(0,i.jsx)(n.code,{children:"false"}),"): Adds ",(0,i.jsx)(n.code,{children:"blend_translate"})," / ",(0,i.jsx)(n.code,{children:"blend_orient"})," attributes to the constrained node (if they don't already exist)."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"skip"})})," (",(0,i.jsx)(n.em,{children:"str"}),", optional): Channels to skip during connection. Use axes like ",(0,i.jsx)(n.code,{children:"x"}),", ",(0,i.jsx)(n.code,{children:"y"}),", ",(0,i.jsx)(n.code,{children:"z"}),", or ",(0,i.jsx)(n.code,{children:"xy"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"skip_translate"})})," (",(0,i.jsx)(n.em,{children:"str"}),", optional): Same as ",(0,i.jsx)(n.code,{children:"skip"}),", but only applies to translate channels (for ",(0,i.jsx)(n.code,{children:"parent"})," constraints)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"skip_rotate"})})," (",(0,i.jsx)(n.em,{children:"str"}),", optional): Same as ",(0,i.jsx)(n.code,{children:"skip"}),", but only applies to rotate channels (for ",(0,i.jsx)(n.code,{children:"parent"})," constraints)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Aim constraint options (",(0,i.jsx)(n.code,{children:"type: aim"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"aim"})})," (",(0,i.jsx)(n.em,{children:"str"})," | ",(0,i.jsx)(n.em,{children:"vector"}),", default: ",(0,i.jsx)(n.code,{children:"x"}),"): Main aim axis of the constrained node."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"up"})})," (",(0,i.jsx)(n.em,{children:"str"})," | ",(0,i.jsx)(n.em,{children:"vector"}),", optional): Local up axis of the constrained node."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"up_vector"})})," (",(0,i.jsx)(n.em,{children:"str"})," | ",(0,i.jsx)(n.em,{children:"vector"}),", optional, default: ",(0,i.jsx)(n.code,{children:"null"}),"): World or object space up vector for the constraint.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"up_object"})," is set, this behaves as the ",(0,i.jsx)(n.em,{children:"object rotation up vector"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["If not, it is treated as a world space vector (",(0,i.jsx)(n.em,{children:"vector"})," mode).",(0,i.jsx)(n.br,{}),"\n","\u26a0\ufe0f ",(0,i.jsx)(n.code,{children:"maintain_offset"})," is not supported in Tangerine in this case yet."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"up_object"})})," (",(0,i.jsx)(n.em,{children:"node"}),", optional): Reference object for the up vector.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"up_vector"})," is ",(0,i.jsx)(n.strong,{children:"not"})," set, this node is used as the target up object (",(0,i.jsx)(n.em,{children:"object up"})," mode).",(0,i.jsx)(n.br,{}),"\n","\u26a0\ufe0f ",(0,i.jsx)(n.code,{children:"maintain_offset"})," is not supported in Tangerine in this case yet."]}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"up_vector"})," ",(0,i.jsx)(n.strong,{children:"is"})," set, it's used ",(0,i.jsx)(n.em,{children:"in object rotation up"})," mode."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"flip"})})," (",(0,i.jsx)(n.em,{children:"bool"}),", default: ",(0,i.jsx)(n.code,{children:"false"}),"): Inverts the aim and up axes."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Vectors can be written as either:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Named axes: ",(0,i.jsx)(n.code,{children:"x"}),", ",(0,i.jsx)(n.code,{children:"y"}),", ",(0,i.jsx)(n.code,{children:"z"}),", ",(0,i.jsx)(n.code,{children:"-x"}),", etc."]}),"\n",(0,i.jsxs)(n.li,{children:["3D vector format: ",(0,i.jsx)(n.code,{children:"[0, 1, 0]"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"output",children:"Output"}),"\n",(0,i.jsxs)(n.p,{children:["The generated constraint node will be named: ",(0,i.jsx)(n.code,{children:"<id>::mod.constraint.<type>.<index>"}),". Its target weights will be exposed on plugs: ",(0,i.jsx)(n.code,{children:"@w0"}),", ",(0,i.jsx)(n.code,{children:"@w1"}),", ",(0,i.jsx)(n.code,{children:"@w2"}),", ..."]}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yml",children:"constraint:\n  type: aim\n  node: <tpl>::infs.0\n  target: <target>::node\n  maintain_offset: on\n  aim: y\n  up: x\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>d});var r=s(6540);const i={},t=r.createContext(i);function c(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);