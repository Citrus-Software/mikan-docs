"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[5594],{7999:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"references/mod/curve","title":"curve","description":"Creates a curve by connecting nodes\' transforms to curve CVs.","source":"@site/docs/references/mod/curve.md","sourceDirName":"references/mod","slug":"/references/mod/curve","permalink":"/mikan-docs/references/mod/curve","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"constraint","permalink":"/mikan-docs/references/mod/constraint"},"next":{"title":"delete","permalink":"/mikan-docs/references/mod/delete"}}');var t=r(4848),o=r(8453);const c={},i="curve",d={},l=[{value:"Options",id:"options",level:2},{value:"Example",id:"example",level:2}];function a(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"curve",children:"curve"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Creates a curve by connecting nodes' transforms to curve CVs."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This modifier generates a curve where each control vertex (CV) is driven by the local transform of a specified node. It's commonly used for visual debugging or helper overlays in rigging."}),"\n",(0,t.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"nodes"})})," (",(0,t.jsx)(n.em,{children:"node"})," | ",(0,t.jsx)(n.em,{children:"list[node]"}),"): One or more nodes whose local matrices will drive the curve CVs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"parent"})})," (",(0,t.jsx)(n.em,{children:"node"}),"): Optional parent for the curve. Defaults to the parent of the first node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"degree"})})," (",(0,t.jsx)(n.em,{children:"int"}),"): Degree of the resulting NURBS curve (typically 1 for linear, 2 for quadratic and 3 for cubic)."]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"name"})})," (",(0,t.jsx)(n.em,{children:"str"}),", optional): Custom name for the curve. Defaults to the formatted ",(0,t.jsx)(n.code,{children:"nice name"})," of the node tag."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yml",children:"[mod]\nhelper:\n  nodes:\n    - spine::ctrls.0\n    - spine::ctrls.1\n    - spine::ctrls.2\n  parent: spine::hooks.mid\n  degree: 3\n  name: spine_curve\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will create a cubic curve named ",(0,t.jsx)(n.code,{children:"spine_curve"}),", parented under ",(0,t.jsx)(n.code,{children:"spine::hooks.mid"}),", and driven by the transforms of the three spine controllers."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>i});var s=r(6540);const t={},o=s.createContext(t);function c(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);