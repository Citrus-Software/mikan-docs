"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1364],{6154:(n,e,o)=>{o.d(e,{A:()=>t});const t=o.p+"assets/images/rig_skull_mid-69e0a279ac3e331b2e39dc3f5d08d1da.png"},7406:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/facial_rig/modifiers","title":"Adding Modifiers","description":"Now that the hierarchy is in place, we move on to the most interesting part: adding all the mechanics with the modifiers.","source":"@site/docs/guides/11-facial_rig/02-modifiers.md","sourceDirName":"guides/11-facial_rig","slug":"/guides/facial_rig/modifiers","permalink":"/mikan-docs/guides/facial_rig/modifiers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Template Hierarchy","permalink":"/mikan-docs/guides/facial_rig/templates"},"next":{"title":"Animator Interface","permalink":"/mikan-docs/guides/facial_rig/ui"}}');var i=o(4848),s=o(8453);const l={},r="Adding Modifiers",a={},d=[{value:"Visibility groups",id:"visibility-groups",level:2},{value:"Skull hooks",id:"skull-hooks",level:2},{value:"Mouth",id:"mouth",level:2},{value:"Hooks",id:"hooks",level:3},{value:"Lips rechain",id:"lips-rechain",level:3},{value:"Lips hooks",id:"lips-hooks",level:3},{value:"Lips corner pinch",id:"lips-corner-pinch",level:3},{value:"Teeth rechain and teeth grab",id:"teeth-rechain-and-teeth-grab",level:3},{value:"Combining lips corner tweakers",id:"combining-lips-corner-tweakers",level:3},{value:"Sticky lips",id:"sticky-lips",level:3},{value:"Sticky teeth",id:"sticky-teeth",level:3},{value:"Cheeks",id:"cheeks",level:2},{value:"Eyebrows",id:"eyebrows",level:2}];function h(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"adding-modifiers",children:"Adding Modifiers"})}),"\n",(0,i.jsx)(e.p,{children:"Now that the hierarchy is in place, we move on to the most interesting part: adding all the mechanics with the modifiers."}),"\n",(0,i.jsx)(e.admonition,{type:"note",children:(0,i.jsx)(e.p,{children:"Reminder: in Mikan, we do not use direct constraints in Maya.\nWe use modifiers, which are instructions read by Mikan during the rig build.\nThis keeps the template clean and flexible."})}),"\n",(0,i.jsx)(e.h2,{id:"visibility-groups",children:"Visibility groups"}),"\n",(0,i.jsx)(e.p,{children:"Let's start with simple modifiers to add visibility groups to the facial-rig controllers."}),"\n",(0,i.jsxs)(e.p,{children:["Groups in the hierarchy gather controllers for select/mirror/flip, but they do not create visibility menus.\nSo we add a ",(0,i.jsx)(e.strong,{children:"helper node"})," named ",(0,i.jsx)(e.code,{children:"_face_vis"})," on the face group, then a ",(0,i.jsx)(e.a,{href:"/mikan-docs/references/mod/group",children:"group"})," modifier to create the visibility menus."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- facial visibility groups\n#?neck::ctrls.head\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - face:::ctrls \n  tag: vis.face\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - mouth1*::ctrls  \n    - mouth2*::ctrls  \n    - mouth3*::ctrls  \n    - mouth4*::ctrls \n  tag: vis.mouth\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - lip1*::ctrls  \n    - lip2*::ctrls  \n    - lip3*::ctrls  \n    - lip4*::ctrls \n  tag: vis.lips\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - cheeks:::ctrls   \n  tag: vis.cheeks\n"})}),"\n",(0,i.jsx)(e.p,{children:"A few important points to keep in mind when working with controller groups:"}),"\n",(0,i.jsxs)(e.p,{children:["The command ",(0,i.jsx)(e.code,{children:"#?neck::ctrls.head"})," ensures that the block only executes if the specified object exists. At first glance, it may seem unnecessary, but it becomes very useful when you want to reuse or extend this template for different characters, allowing you to safely run commands without affecting other rigs that may not share the same hierarchy."]}),"\n",(0,i.jsxs)(e.p,{children:["Another option is to declare a variable like that: ",(0,i.jsx)(e.code,{children:"#>ctrl: neck::ctrls.head"}),". This lets you replace all occurrences of this controller in the block with ",(0,i.jsx)(e.code,{children:"<ctrl>"}),", making it easy to edit all commands at once using a single variable."]}),"\n",(0,i.jsxs)(e.p,{children:["The triple-colon notation in ",(0,i.jsx)(e.code,{children:"face:::ctrls"})," is used to select the group and all of its children. Using ",(0,i.jsx)(e.code,{children:"face::ctrls"})," (double colon) would select only the direct members of the face group, but in our setup, the face group itself contains no controllers. Extending the selection with ",(0,i.jsx)(e.code,{children:":::"})," ensures that all controllers within the hierarchy are included in the operation."]}),"\n",(0,i.jsx)(e.h2,{id:"skull-hooks",children:"Skull hooks"}),"\n",(0,i.jsxs)(e.p,{children:["We now move on to the constraints used to deform the skull. The goal here is to allow the face to ",(0,i.jsx)(e.strong,{children:"bend and adapt"})," as the upper and lower parts of the head move independently. To achieve this, we define two constraint targets: ",(0,i.jsx)(e.code,{children:"skull"})," for the upper part of the head, and ",(0,i.jsx)(e.code,{children:"jaw_up"})," for the lower part."]}),"\n",(0,i.jsxs)(e.p,{children:["The actual constraint is created using the ",(0,i.jsx)(e.a,{href:"/mikan-docs/references/mod/hook",children:"hook"})," modifier, which internally works as a matrix-based constraint. This allows ",(0,i.jsx)(e.code,{children:"skull_mid"})," to interpolate cleanly between its two parents and provides a stable foundation for flexible head deformation."]}),"\n",(0,i.jsxs)(e.p,{children:["To do this, create a ",(0,i.jsx)(e.strong,{children:"helper node"})," named ",(0,i.jsx)(e.code,{children:"_face_hooks"})," on the face group and add the following commands:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- skull mid hooks\nhook:\n  nodes:\n   - skull_mid::roots\n  targets: \n   - skull::skin.0\n   - jaw_up::skin.0\n  self: on\n"})}),"\n",(0,i.jsxs)(e.p,{children:["For cartoon rigs in particular, it is often useful to give animators control over how malleable the middle of the face is. Depending on the shot, you may want the mid-face to follow the skull rigidly, follow the jaw more closely, or blend between the two. To support this, we add a ",(0,i.jsx)(e.strong,{children:"blend control on the constraint weights"}),"."]}),"\n",(0,i.jsxs)(e.p,{children:["Using the ",(0,i.jsx)(e.a,{href:"/mikan-docs/references/mod/plug",children:"plug"})," command, we add an animation attribute to the ",(0,i.jsx)(e.code,{children:"skull_mid"})," controller. The ",(0,i.jsx)(e.code,{children:"hook"})," modifier creates two weight attributes, ",(0,i.jsx)(e.code,{children:"w0"})," and ",(0,i.jsx)(e.code,{children:"w1"}),", corresponding to the two constraint targets. By default, both weights are set to ",(0,i.jsx)(e.strong,{children:"1"}),". We then connect the animator-facing slider so that a value of ",(0,i.jsx)(e.strong,{children:"0"})," drives ",(0,i.jsx)(e.code,{children:"w0"})," to ",(0,i.jsx)(e.strong,{children:"1"})," and ",(0,i.jsx)(e.code,{children:"w1"})," to ",(0,i.jsx)(e.strong,{children:"0"}),", and a value of ",(0,i.jsx)(e.strong,{children:"1"})," does the opposite. This effectively allows the animator to switch, or smoothly blend, the parent influence between ",(0,i.jsx)(e.code,{children:"skull"})," and ",(0,i.jsx)(e.code,{children:"jaw_up"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"This setup gives direct artistic control over mid-face deformation while keeping the underlying rig structure simple and predictable."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"plug:\n  node: skull_mid::ctrls.0\n  slide: {k: on, min: 0, max: 1, set: $slide}\n\nconnect:\n  input: skull_mid::ctrls.0@slide\n  node: skull_mid::roots.0@w0\nconnect:\n  input: skull_mid::ctrls.0@slide\n  node: skull_mid::roots.0@w1\n  op: reverse\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"rig skull mid",src:o(6154).A+"",width:"1000",height:"730"})}),"\n",(0,i.jsx)(e.h2,{id:"mouth",children:"Mouth"}),"\n",(0,i.jsx)(e.h3,{id:"hooks",children:"Hooks"}),"\n",(0,i.jsxs)(e.p,{children:["We can now move on to the ",(0,i.jsx)(e.strong,{children:"mouth deformation rig"}),". In this section, we install the system that allows the jaws to drive the lip controllers and the various mouth tweakers that shape the deformation."]}),"\n",(0,i.jsxs)(e.p,{children:["We start by constraining the main ",(0,i.jsx)(e.code,{children:"mouth"})," controller between ",(0,i.jsx)(e.code,{children:"jaw"})," and ",(0,i.jsx)(e.code,{children:"jaw_up"})," using a ",(0,i.jsx)(e.a,{href:"/mikan-docs/references/mod/hook",children:"hook"})," modifier, following the same approach used earlier with ",(0,i.jsx)(e.code,{children:"skull_mid"}),". As before, we add a switch on this controller to define how it is attached by default, allowing us to blend or switch its parent influence."]}),"\n",(0,i.jsxs)(e.p,{children:["In addition, we introduce an ",(0,i.jsx)(e.strong,{children:"adjustable variable"})," on the helper node. This variable can be used directly inside the command, making it possible to expose only the default switch value to the artists responsible for assembling the rig, without requiring them to dig into the command logic."]}),"\n",(0,i.jsxs)(e.p,{children:["To do this, we simply declare a ",(0,i.jsx)(e.code,{children:"$variable"})," in the command in place of a numeric value. The rig builder will automatically look for the corresponding attribute named ",(0,i.jsx)(e.code,{children:"gem_var_variable"})," on the helper node. If the attribute does not exist, it will be created automatically and initialized to ",(0,i.jsx)(e.strong,{children:"0"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"This approach keeps the commands flexible while making default behavior easy to adjust at build time."}),"\n",(0,i.jsxs)(e.p,{children:["Create a ",(0,i.jsx)(e.strong,{children:"helper node"})," named ",(0,i.jsx)(e.code,{children:"_mouth_hook"})," under ",(0,i.jsx)(e.code,{children:"mouth"})," module and add the following commands:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- mouth rig\nhook:  \n  nodes: mouth::roots.0  \n  targets:   \n    - jaw_up::skin.0   \n    - jaw::skin.0  \n  group: on  \n  name: jaw_mid\n\nconnect:\n  input: mouth::mod.hooks.jaw_mid@w0\n  node: mouth::mod.hooks.jaw_mid@w1\n  op: reverse\n\nplug:\n  node: mouth::mod.hooks.jaw_mid\n  w0: {set: $jaw_mid_weight}\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"rig mouth",src:o(8327).A+"",width:"1228",height:"740"})}),"\n",(0,i.jsx)(e.h3,{id:"lips-rechain",children:"Lips rechain"}),"\n",(0,i.jsxs)(e.p,{children:["Now that the mouth controller is properly constrained, we can see that the main lip controllers (",(0,i.jsx)(e.code,{children:"lip_up"}),", ",(0,i.jsx)(e.code,{children:"lip_dn"}),") and the mouth corners (",(0,i.jsx)(e.code,{children:"lips_corner.L"}),", ",(0,i.jsx)(e.code,{children:"lips_corner.R"}),") do not automatically follow it. A straightforward solution would be to parent everything directly under ",(0,i.jsx)(e.code,{children:"mouth"}),", but that would be too limiting. In practice, we want ",(0,i.jsx)(e.code,{children:"lip_up"})," and ",(0,i.jsx)(e.code,{children:"lip_dn"})," to continue following their respective jaws, while still being influenced by the global mouth control."]}),"\n",(0,i.jsxs)(e.p,{children:["To achieve this, we introduce the concept of a ",(0,i.jsx)(e.strong,{children:"virtual hierarchy"})," using the ",(0,i.jsx)(e.a,{href:"/mikan-docs/references/mod/rig/rechain",children:(0,i.jsx)(e.code,{children:"rig.rechain"})})," modifier. This modifier can be a bit unintuitive at first, but once properly understood, it becomes a very powerful tool."]}),"\n",(0,i.jsxs)(e.p,{children:["The idea is simple: the physical hierarchy remains driven by the jaws, while an additional virtual parent allows the lips to inherit motion from the ",(0,i.jsx)(e.code,{children:"mouth"})," controller."]}),"\n",(0,i.jsxs)(e.p,{children:["We first create a helper node to host all commands related to the lip rig. This helper is parented under the ",(0,i.jsx)(e.code,{children:"lips"})," group and named ",(0,i.jsx)(e.code,{children:"_lips_rig"}),"."]}),"\n",(0,i.jsxs)(e.p,{children:["We then add commands to parent ",(0,i.jsx)(e.code,{children:"lip_up"})," under ",(0,i.jsx)(e.code,{children:"jaw_up"})," and ",(0,i.jsx)(e.code,{children:"lip_dn"})," under ",(0,i.jsx)(e.code,{children:"jaw"}),". This ensures that each lip controller follows its corresponding jaw by default. Once this physical hierarchy is in place, we use ",(0,i.jsx)(e.code,{children:"rig.rechain"})," to make both lip controllers also follow the ",(0,i.jsx)(e.code,{children:"mouth"})," controller, effectively inserting it as a virtual parent."]}),"\n",(0,i.jsxs)(e.p,{children:["This is also a good opportunity to introduce the notion of ",(0,i.jsx)(e.strong,{children:"execution priority"}),". The build process does not strictly follow a deterministic order based on hierarchy. While parent-child relationships define dependencies, the order in which sibling nodes are parsed cannot be guaranteed. When a specific sequence is required, timing offsets must be used to enforce it."]}),"\n",(0,i.jsxs)(e.p,{children:["In this case, we want to make sure that all constraint-related setup for the lips has already been built before applying the rechain logic. We therefore delay execution slightly using ",(0,i.jsx)(e.code,{children:"#!-10"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"The resulting setup allows the lips to correctly inherit motion from both the jaws and the global mouth controller, without compromising the underlying hierarchy."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n#!-10\nparent: lip_up::roots.0 jaw_up::skin.0\nparent: lip_dn::roots.0 jaw::skin.0\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - lip_up::roots.0\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - lip_dn::roots.0\n"})}),"\n",(0,i.jsx)(e.h3,{id:"lips-hooks",children:"Lips hooks"}),"\n",(0,i.jsx)(e.p,{children:"On the same helper node, we add modifiers to hook the c_mouth controllers with weight attributes, so we can manage the follow between mouth and lip_up / lip_dn."}),"\n",(0,i.jsx)(e.p,{children:"The intended behavior is:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"mouth1"})," fully follows the lips,"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"mouth4"})," stays entirely on mouth,"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"intermediate controllers"})," have ",(0,i.jsx)(e.strong,{children:"progressive follow values"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This gives a coherent and smooth deformation across the entire mouth line."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- lips up/dn hooks\n#> n: ['2', '2b', '3']\n#> side: [up, dn]\n\nhook:\n  node: mouth1_<side>::roots.0\n  targets:\n   - lip_<side>::skin.0\n  group: on\n  name: lip1_<side>\nhook:\n  node: mouth<n>_<side>::roots.0\n  targets:\n   - lip_<side>::skin.0\n   - mouth::skin.0\n  group: on\n  name: lip<n>_<side>\nhook:\n  nodes: mouth4::roots.0\n  targets:\n   - mouth::skin.0\n  group: on\n  name: lip4\n\nconnect:\n  input: lips::mod.hooks.lip<n>_<side>@w0\n  node: lips::mod.hooks.lip<n>_<side>@w1\n  op: reverse\n\nplug:\n  node: lips::mod.hooks.lip<n>_<side>\n  w0: {set: $mouth<n>_<side>_weight}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"lips-corner-pinch",children:"Lips corner pinch"}),"\n",(0,i.jsxs)(e.p,{children:["Still on the same helper, we add the modifiers to build a ",(0,i.jsx)(e.strong,{children:"sticky corner"})," system.\nWe create a ",(0,i.jsx)(e.strong,{children:"corners_pinch attribute"}),", then connect it to the ",(0,i.jsx)(e.strong,{children:"weights"})," of the hooks for mouth2 and mouth3."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky corner switch\n#> n: ['2', '2b']\n#> side: [up, dn]\nplug:\n  node: mouth::ctrls.0\n  corners_pinch: {set: 0, k: on, min: -1, max: 1}\n\ndrive:\n  node: mouth::ctrls.0@corners_pinch\n  lips::mod.hooks.lip<n>_<side>@w0:\n    1: $mouth<n>_<side>_weight\n    0: $mouth<n>_<side>_weight\n    -1: 1\n\ndrive:\n  node: mouth::ctrls.0@corners_pinch\n  lips::mod.hooks.lip3_<side>@w0:\n    1: 0\n    0: $mouth3_<side>_weight\n    -1: 1\n"})}),"\n",(0,i.jsx)(e.h3,{id:"teeth-rechain-and-teeth-grab",children:"Teeth rechain and teeth grab"}),"\n",(0,i.jsxs)(e.p,{children:["Following the same logic, we rig the ",(0,i.jsx)(e.strong,{children:"teeth"})," so they can ",(0,i.jsx)(e.strong,{children:"follow (or not) c_mouth"}),".\nWe create a ",(0,i.jsx)(e.strong,{children:"virtual hierarchy"})," between c_mouth and c_teeth, using the weight option to enable or disable the transform constraint."]}),"\n",(0,i.jsx)(e.p,{children:"We then add an attribute on c_mouth to control the weight of this constraint."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- teeth subtransform\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - teeth_up::roots.0\n  weight: on\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - teeth_dn::roots.0\n  weight: on\n\nplug:\n  node: mouth::ctrls.0\n  grab_teeth:\n    k: on\n    min: 0\n    max: 1\n\nconnect:\n  input: mouth::ctrls.0@grab_teeth\n  node: teeth_up::roots.0@weight\nconnect:\n  input: mouth::ctrls.0@grab_teeth\n  node: teeth_dn::roots.0@weight\n"})}),"\n",(0,i.jsx)(e.h3,{id:"combining-lips-corner-tweakers",children:"Combining lips corner tweakers"}),"\n",(0,i.jsx)(e.p,{children:"We now set up the connections so that mouth3 up/dn and mouth4 are driven by both c_mouth and c_corner, while still following lip_up and lip_dn."}),"\n",(0,i.jsx)(e.p,{children:"To do this, we again use rig.rechain, which allows us to build a virtual hierarchy without breaking existing dependencies."}),"\n",(0,i.jsx)(e.p,{children:"The order of the constraints is essential:\nthe mouth controllers must follow c_corner first, then lip_up/dn."}),"\n",(0,i.jsx)(e.p,{children:"We proceed as follows:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Create locators under sk_mouth."}),"\n",(0,i.jsx)(e.li,{children:"Create additional locators under the hooks of mouth3 and mouth4, replacing the controllers."}),"\n",(0,i.jsx)(e.li,{children:"Reparent the mouth controllers under c_corner."}),"\n",(0,i.jsx)(e.li,{children:"Rebuild the hierarchy between the hooks and controllers using rig.rechain."}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- mouth corner rig (subtransforms)\n\n#!-10\n#> lip: ['3_up', '4', '3_dn']\n\nlocator:\n  node: mouth<lip>.L::ctrls.0\n  parent: mouth::skin.0\n  name: orig_mouth_<lip>\n\nlocator:\n  node: mouth<lip>.L::ctrls.0\n  parent: lips::mod.hooks.lip<lip>\n  name: mouth_<lip>\n\nparent:\n  - mouth<lip>.L::roots.0\n  - lips_corner.L::skin.0\n\nrig.rechain:\n  roots:\n   - lips_corner.L::mod.loc.orig_mouth_<lip>\n  ctrls:\n   - lips_corner.L::mod.loc.mouth_<lip>\n  nodes:\n   - mouth<lip>.L::roots.0\n"})}),"\n",(0,i.jsx)(e.h3,{id:"sticky-lips",children:"Sticky lips"}),"\n",(0,i.jsxs)(e.p,{children:["We start by creating the sticky attributes on ",(0,i.jsx)(e.strong,{children:"shp_lips"}),", which will later be connected to chan_face for animator access."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky lips settings\n#!10\n\nplug:\n m_sticky_L: {add: float, k: on, set: 0, min: 0, max: 2}\n m_sticky_R: {add: float, k: on, set: 0, min: 0, max: 2}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["We then set up the ",(0,i.jsx)(e.strong,{children:"sticky rig"})," by creating a helper ",(0,i.jsx)(e.strong,{children:"node"})," under the Lips group."]}),"\n",(0,i.jsxs)(e.p,{children:["We first create ",(0,i.jsx)(e.strong,{children:"midpoint locators"})," between up and dn for ",(0,i.jsx)(e.strong,{children:"lip1, lip2, and lip3"}),", then reference locators for up/dn positions."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky lips rig\n#!-5\n\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip1_mid\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2_mid.L\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2b_mid.L \nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip3_mid.L\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2_mid.R\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2b_mid.R\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip3_mid.R\n\n\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip1_mid\n  targets:\n   - mouth1_up::poses\n   - mouth1_dn::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2_mid.L\n  targets:\n   - mouth2_up.L::poses\n   - mouth2_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2b_mid.L\n  targets:\n   - mouth2b_up.L::poses\n   - mouth2b_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip3_mid.L\n  targets:\n   - mouth3_up.L::poses\n   - mouth3_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2_mid.R\n  targets:\n   - mouth2_up.R::poses\n   - mouth2_dn.R::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2b_mid.R\n  targets:\n   - mouth2b_up.R::poses\n   - mouth2b_dn.R::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip3_mid.R\n  targets:\n   - mouth3_up.R::poses\n   - mouth3_dn.R::poses\n\nlocator:\n  node: lip1_up::roots.0\n  parent: lips::mod.loc.lip1_mid\n  name: lip1_up\nlocator:\n  node: lip2_up.L::roots.0\n  parent: lips::mod.loc.lip2_mid.L\n  name: lip2_up.L\nlocator:\n  node: lip2b_up.L::roots.0\n  parent: lips::mod.loc.lip2b_mid.L\n  name: lip2b_up.L\nlocator:\n  node: lip3_up.L::roots.0\n  parent: lips::mod.loc.lip3_mid.L\n  name: lip3_up.L\nlocator:\n  node: lip2_up.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2_up.R\nlocator:\n  node: lip2b_up.R::roots.0\n  parent: lips::mod.loc.lip2b_mid.R\n  name: lip2b_up.R\nlocator:\n  node: lip3_up.R::roots.0\n  parent: lips::mod.loc.lip3_mid.R\n  name: lip3_up.R\n\nlocator:\n  node: lip1_dn::roots.0\n  parent: lips::mod.loc.lip1_mid\n  name: lip1_dn\nlocator:\n  node: lip2_dn.L::roots.0\n  parent: lips::mod.loc.lip2_mid.L\n  name: lip2_dn.L\nlocator:\n  node: lip2b_dn.L::roots.0\n  parent: lips::mod.loc.lip2b_mid.L\n  name: lip2b_dn.L\nlocator:\n  node: lip3_dn.L::roots.0\n  parent: lips::mod.loc.lip3_mid.L\n  name: lip3_dn.L\nlocator:\n  node: lip2_dn.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2_dn.R\nlocator:\n  node: lip2b_dn.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2b_dn.R\nlocator:\n  node: lip3_dn.R::roots.0\n  parent: lips::mod.loc.lip3_mid.R\n  name: lip3_dn.R\n\n\nhook:\n  node: lip1_up::infs.0\n  target: lips::mod.loc.lip1_up\n  weights: [1]\n\nhook:\n  node: lip1_dn::infs.0\n  target: lips::mod.loc.lip1_dn\n  weights: [1]\n\nhook:\n  node: lip2_up.L::infs.0\n  target: lips::mod.loc.lip2_up.L\n  weights: [1]\n\nhook:\n  node: lip2_dn.L::infs.0\n  target: lips::mod.loc.lip2_dn.L\n  weights: [1]\n\nhook:\n  node: lip2b_up.L::infs.0\n  target: lips::mod.loc.lip2b_up.L\n  weights: [1]\n\nhook:\n  node: lip2b_dn.L::infs.0\n  target: lips::mod.loc.lip2b_dn.L\n  weights: [1]\n\nhook:\n  node: lip3_up.L::infs.0\n  target: lips::mod.loc.lip3_up.L\n  weights: [1]\n\nhook:\n  node: lip3_dn.L::infs.0\n  target: lips::mod.loc.lip3_dn.L\n  weights: [1]\n\nhook:\n  node: lip2_up.R::infs.0\n  target: lips::mod.loc.lip2_up.R\n  weights: [1]\n\nhook:\n  node: lip2_dn.R::infs.0\n  target: lips::mod.loc.lip2_dn.R\n  weights: [1]\n\nhook:\n  node: lip2b_up.R::infs.0\n  target: lips::mod.loc.lip2b_up.R\n  weights: [1]\n\nhook:\n  node: lip2b_dn.R::infs.0\n  target: lips::mod.loc.lip2b_dn.R\n  weights: [1]\n\nhook:\n  node: lip3_up.R::infs.0\n  target: lips::mod.loc.lip3_up.R\n  weights: [1]\n\nhook:\n  node: lip3_dn.R::infs.0\n  target: lips::mod.loc.lip3_dn.R\n  weights: [1]\n"})}),"\n",(0,i.jsx)(e.p,{children:"Finally, we set up the drives and expressions controlling the sticky behavior."}),"\n",(0,i.jsx)(e.p,{children:"Start with values that seem reasonable. You can adjust them as you test the rig."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"drive:\n  node: shp_lips::node@m_sticky_L\n  shp_lips::node@s3l:\n    0: {v: 0, tan: linear}\n    0.25: {v: 0.5, ox: 0.25, oy: 0.5}\n    1: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2bl:\n    0: {v: 0, tan: flat}\n    0.375: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2l:\n    0: {v: 0, tan: flat}\n    0.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s1:\n    0.25: {v: 0, tan: flat}\n    1: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.75: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2r:\n    0.75: {v: 0, tan: flat}\n    1.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2br:\n    0.75: {v: 0, tan: flat}\n    1.625: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s3r:\n    1: {v: 0, tan: flat}\n    1.75: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: linear}\n    pre: constant\n    post: constant\n\ndrive:\n  node: shp_lips::node@m_sticky_R\n  shp_lips::node@s3r:\n    0: {v: 0, tan: linear}\n    0.25: {v: 0.5, ox: 0.25, oy: 0.5}\n    1: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  node: shp_lips::node@m_sticky_R\n  shp_lips::node@s2br:\n    0: {v: 0, tan: flat}\n    0.375: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2r:\n    0: {v: 0, tan: flat}\n    0.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s1:\n    0.25: {v: 0, tan: flat}\n    1: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.75: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2l:\n    0.75: {v: 0, tan: flat}\n    1.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2bl:\n    0.75: {v: 0, tan: flat}\n    1.625: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s3l:\n    1: {v: 0, tan: flat}\n    1.75: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: linear}\n    pre: constant\n    post: constant\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip3_up.L::infs.0@w0\n  x: shp_lips::node@s3l\n\nconnect:\n  input: lip3_up.L::infs.0@w0\n  node: lip3_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2b_up.L::infs.0@w0\n  x: shp_lips::node@s2bl\nconnect:\n  input: lip2b_up.L::infs.0@w0\n  node: lip2b_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2_up.L::infs.0@w0\n  x: shp_lips::node@s2l\n\nconnect:\n  input: lip2_up.L::infs.0@w0\n  node: lip2_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip1_up::infs.0@w0\n  x: shp_lips::node@s1\n\nconnect:\n  input: lip1_up::infs.0@w0\n  node: lip1_dn::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2_up.R::infs.0@w0\n  x: shp_lips::node@s2r\n\nconnect:\n  input: lip2_up.R::infs.0@w0\n  node: lip2_dn.R::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2b_up.R::infs.0@w0\n  x: shp_lips::node@s2br\n\nconnect:\n  input: lip2b_up.R::infs.0@w0\n  node: lip2b_dn.R::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip3_up.R::infs.0@w0\n  x: shp_lips::node@s3r\n\nconnect:\n  input: lip3_up.R::infs.0@w0\n  node: lip3_dn.R::infs.0@w0\n"})}),"\n",(0,i.jsx)(e.h3,{id:"sticky-teeth",children:"Sticky teeth"}),"\n",(0,i.jsxs)(e.p,{children:["The principle is the ",(0,i.jsx)(e.strong,{children:"same"})," as with the sticky lips, except the sticky should ",(0,i.jsx)(e.strong,{children:"activate uniformly"})," across all teeth.\nWe create a ",(0,i.jsx)(e.strong,{children:"_sticky_teeth helper node"})," under the Lips group to store these modifiers."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\nlocator:\n  node: teeth_dn::skin.0\n  parent: jaw::skin.0\n  name: teeth_mid\n\nhook:\n  self: on\n  targets:\n    - teeth_up::skin.0\n    - teeth_dn::skin.0\n  node: lips::mod.loc.teeth_mid\n  weights: [0.5, 0.5]\n\n#> y: [up, dn]\n#> x: [L, R]\nlocator:\n  node: teeth_bend_<y>.<x>::poses.0\n  parent: lips::mod.loc.teeth_mid\n  name: copy_teeth_tip_<y>_<x>\n  copycat: on\n\nlocator:\n  node: teeth_tip_<y>::hooks.0\n  parent: lips::mod.loc.teeth_mid\n  name: teeth_tip_<y>\nlocator:\n  node: teeth_bend_tip_<y>.<x>::hooks.0\n  parent: lips::mod.loc.copy_teeth_tip_<y>_<x>\n  name: teeth_tip_<y>_<x>\n\nhook:\n  target: lips::mod.loc.teeth_tip_<y>\n  node: teeth_tip_<y>::roots.0\n  weights: [1]\nhook:\n  target: lips::mod.loc.teeth_tip_<y>_<x>\n  node: teeth_bend_tip_<y>.<x>::roots.0\n  weights: [1]\n\n\nplug:\n  node: shp_lips::node\n  t_sticky: {type: float, k: on}\n\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_tip_<y>::roots.0@w0\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_tip_<y>::roots.0@w1\n  op: reverse\n\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_bend_tip_<y>.<x>::roots.0@w0\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_bend_tip_<y>.<x>::roots.0@w1\n  op: reverse\n"})}),"\n",(0,i.jsx)(e.h2,{id:"cheeks",children:"Cheeks"}),"\n",(0,i.jsxs)(e.p,{children:["Next, we rig the ",(0,i.jsx)(e.strong,{children:"cheeks"})," by attaching their controllers to the facial structure.\nWe add ",(0,i.jsx)(e.strong,{children:"hook"})," modifiers on a helper node placed under skull_mid."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\nparent:\n  - chin::roots\n  - jaw::hooks.0\n\nhook:\n  nodes:\n   - cheek1::roots\n   - nasolabial1::roots\n  targets:\n   - jaw_up::skin.0\n   - jaw::skin.0\n  parent: neck::hooks.head\n  name: cheek_mid\n\nhook:\n  nodes:\n   - cheek2::roots\n   - cheek3::roots\n  targets:\n   - skull::skin.0\n   - skull_mid::skin.0\n   - jaw_up::skin.0\n  weights: [0.35, 0.5, 0.15]\n  parent: neck::hooks.head\n  name: cheek_nose\n\nhook:\n  nodes:\n   - nasolabial2::roots\n   - lip_upper::roots\n  targets:\n   - jaw_up::skin.0\n   - skull_mid::skin.0\n  weights: [0.65, 0.35]\n  parent: neck::hooks.head\n  name: jaw_up_nose\n"})}),"\n",(0,i.jsx)(e.h2,{id:"eyebrows",children:"Eyebrows"}),"\n",(0,i.jsxs)(e.p,{children:["We finish with the eyebrows rig.\nWe add a ",(0,i.jsx)(e.strong,{children:"hook"})," constraint so the eyebrows can either ",(0,i.jsx)(e.strong,{children:"follow or ignore"})," the eyeroots.\nWe use a helper node on eyebrow_base, with a ",(0,i.jsx)(e.strong,{children:"hook"})," modifier and a ",(0,i.jsx)(e.strong,{children:"follow plug"}),"."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"[mod]\nhook:\n  self: on\n  node: eyebrow_base.L::roots.0\n  target: eye_root.L::skin.0\n  weight: 1\n\nplug:\n  node: eyebrow_base.L::ctrls.0\n  follow_skull: {set: 0, k: on, min: 0, max: 1}\n\nconnect:\n  input: eyebrow_base.L::ctrls.0@follow_skull\n  op: reverse\n  node: eyebrow_base.L::roots.0@w0\n"})})]})}function c(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}},8327:(n,e,o)=>{o.d(e,{A:()=>t});const t=o.p+"assets/images/rig_mouth-de1176b812cae40af070ba894654b74d.png"},8453:(n,e,o)=>{o.d(e,{R:()=>l,x:()=>r});var t=o(6540);const i={},s=t.createContext(i);function l(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:l(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);