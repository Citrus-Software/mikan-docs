"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2837],{28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>d});var s=r(96540);const t={},o=s.createContext(t);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}},74702:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"references/mod/reset","title":"reset","description":"Ensures specified nodes are reset to their bind transform when the rig is rebuilt.","source":"@site/docs/references/mod/reset.md","sourceDirName":"references/mod","slug":"/references/mod/reset","permalink":"/mikan-docs/references/mod/reset","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"plug","permalink":"/mikan-docs/references/mod/plug"},"next":{"title":"rig.bank","permalink":"/mikan-docs/references/mod/rig/bank"}}');var t=r(74848),o=r(28453);const i={},d="reset",c={},l=[{value:"Options",id:"options",level:2},{value:"Example",id:"example",level:2}];function a(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"reset",children:"reset"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Ensures specified nodes are reset to their bind transform when the rig is rebuilt."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When this modifier is executed, it stores the current transform of the node(s). This saved state will then be used during rig rebuild to restore their position."}),"\n",(0,t.jsx)(n.p,{children:'This is useful for objects like constraint geometry groups that aren\'t included in the automatic bind pose group, it ensures they return to the expected position even after rig deletion, which can leave them "stranded" in world space after a teardown. Using this modifier ensures those nodes are correctly reset alongside the rest of the rig.'}),"\n",(0,t.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"node"})}),", ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"nodes"})})," (",(0,t.jsx)(n.em,{children:"node"})," | ",(0,t.jsx)(n.em,{children:"list[node]"}),"): Nodes to reset."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yml",children:"[mod]\nreset:\n  nodes: geo_group->xfo\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will ensure that ",(0,t.jsx)(n.code,{children:"geo_group"})," is reset when the rig is rebuilt if it has been moved."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);