"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1364],{6154:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/rig_skull_mid-69e0a279ac3e331b2e39dc3f5d08d1da.png"},7406:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/facial_rig/modifiers","title":"Adding Modifiers","description":"Now that the hierarchy is in place, we move on to the most interesting part: adding all the mechanics with the modifiers.","source":"@site/docs/guides/11-facial_rig/02-modifiers.md","sourceDirName":"guides/11-facial_rig","slug":"/guides/facial_rig/modifiers","permalink":"/mikan-docs/guides/facial_rig/modifiers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Template Hierarchy","permalink":"/mikan-docs/guides/facial_rig/templates"},"next":{"title":"Animator Interface","permalink":"/mikan-docs/guides/facial_rig/ui"}}');var i=o(4848),s=o(8453);const l={},r="Adding Modifiers",a={},d=[{value:"Visibility groups",id:"visibility-groups",level:2},{value:"Skull hooks",id:"skull-hooks",level:2},{value:"Mouth",id:"mouth",level:2},{value:"Hooks",id:"hooks",level:3},{value:"Lips rechain",id:"lips-rechain",level:3},{value:"Lip tweakers hooks",id:"lip-tweakers-hooks",level:3},{value:"Lips corner pinch",id:"lips-corner-pinch",level:3},{value:"Combining lips corner tweakers",id:"combining-lips-corner-tweakers",level:3},{value:"Sticky lips",id:"sticky-lips",level:3},{value:"Teeth rechain and teeth grab",id:"teeth-rechain-and-teeth-grab",level:3},{value:"Sticky teeth",id:"sticky-teeth",level:3},{value:"Cheeks",id:"cheeks",level:2},{value:"Eyebrows",id:"eyebrows",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"adding-modifiers",children:"Adding Modifiers"})}),"\n",(0,i.jsx)(n.p,{children:"Now that the hierarchy is in place, we move on to the most interesting part: adding all the mechanics with the modifiers."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Reminder: in Mikan, we do not use direct constraints in Maya.\nWe use modifiers, which are instructions read by Mikan during the rig build.\nThis keeps the template clean and flexible."})}),"\n",(0,i.jsx)(n.h2,{id:"visibility-groups",children:"Visibility groups"}),"\n",(0,i.jsx)(n.p,{children:"Let's start with simple modifiers to add visibility groups to the facial-rig controllers."}),"\n",(0,i.jsxs)(n.p,{children:["Groups in the hierarchy gather controllers for select/mirror/flip, but they do not create visibility menus.\nSo we add a ",(0,i.jsx)(n.strong,{children:"helper node"})," named ",(0,i.jsx)(n.code,{children:"_face_vis"})," on the face group, then a ",(0,i.jsx)(n.a,{href:"/mikan-docs/references/mod/group",children:"group"})," modifier to create the visibility menus."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- facial visibility groups\n#?neck::ctrls.head\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - face:::ctrls \n  tag: vis.face\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - mouth1*::ctrls  \n    - mouth2*::ctrls  \n    - mouth3*::ctrls  \n    - mouth4*::ctrls \n  tag: vis.mouth\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - lip1*::ctrls  \n    - lip2*::ctrls  \n    - lip3*::ctrls  \n    - lip4*::ctrls \n  tag: vis.lips\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - cheeks:::ctrls   \n  tag: vis.cheeks\n"})}),"\n",(0,i.jsx)(n.p,{children:"A few important points to keep in mind when working with controller groups:"}),"\n",(0,i.jsxs)(n.p,{children:["The command ",(0,i.jsx)(n.code,{children:"#?neck::ctrls.head"})," ensures that the block only executes if the specified object exists. At first glance, it may seem unnecessary, but it becomes very useful when you want to reuse or extend this template for different characters, allowing you to safely run commands without affecting other rigs that may not share the same hierarchy."]}),"\n",(0,i.jsxs)(n.p,{children:["Another option is to declare a variable like that: ",(0,i.jsx)(n.code,{children:"#>ctrl: neck::ctrls.head"}),". This lets you replace all occurrences of this controller in the block with ",(0,i.jsx)(n.code,{children:"<ctrl>"}),", making it easy to edit all commands at once using a single variable."]}),"\n",(0,i.jsxs)(n.p,{children:["The triple-colon notation in ",(0,i.jsx)(n.code,{children:"face:::ctrls"})," is used to select the group and all of its children. Using ",(0,i.jsx)(n.code,{children:"face::ctrls"})," (double colon) would select only the direct members of the face group, but in our setup, the face group itself contains no controllers. Extending the selection with ",(0,i.jsx)(n.code,{children:":::"})," ensures that all controllers within the hierarchy are included in the operation."]}),"\n",(0,i.jsx)(n.h2,{id:"skull-hooks",children:"Skull hooks"}),"\n",(0,i.jsxs)(n.p,{children:["We now move on to the constraints used to deform the skull. The goal here is to allow the face to ",(0,i.jsx)(n.strong,{children:"bend and adapt"})," as the upper and lower parts of the head move independently. To achieve this, we define two constraint targets: ",(0,i.jsx)(n.code,{children:"skull"})," for the upper part of the head, and ",(0,i.jsx)(n.code,{children:"jaw_up"})," for the lower part."]}),"\n",(0,i.jsxs)(n.p,{children:["The actual constraint is created using the ",(0,i.jsx)(n.a,{href:"/mikan-docs/references/mod/hook",children:"hook"})," modifier, which internally works as a matrix-based constraint. This allows ",(0,i.jsx)(n.code,{children:"skull_mid"})," to interpolate cleanly between its two parents and provides a stable foundation for flexible head deformation."]}),"\n",(0,i.jsxs)(n.p,{children:["To do this, create a ",(0,i.jsx)(n.strong,{children:"helper node"})," named ",(0,i.jsx)(n.code,{children:"_face_hooks"})," on the face group and add the following commands:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- skull mid hooks\nhook:\n  nodes:\n   - skull_mid::roots\n  targets: \n   - skull::skin.0\n   - jaw_up::skin.0\n  self: on\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For cartoon rigs in particular, it is often useful to give animators control over how malleable the middle of the face is. Depending on the shot, you may want the mid-face to follow the skull rigidly, follow the jaw more closely, or blend between the two. To support this, we add a ",(0,i.jsx)(n.strong,{children:"blend control on the constraint weights"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Using the ",(0,i.jsx)(n.a,{href:"/mikan-docs/references/mod/plug",children:"plug"})," command, we add an animation attribute to the ",(0,i.jsx)(n.code,{children:"skull_mid"})," controller. The ",(0,i.jsx)(n.code,{children:"hook"})," modifier creates two weight attributes, ",(0,i.jsx)(n.code,{children:"w0"})," and ",(0,i.jsx)(n.code,{children:"w1"}),", corresponding to the two constraint targets. By default, both weights are set to ",(0,i.jsx)(n.strong,{children:"1"}),". We then connect the animator-facing slider so that a value of ",(0,i.jsx)(n.strong,{children:"0"})," drives ",(0,i.jsx)(n.code,{children:"w0"})," to ",(0,i.jsx)(n.strong,{children:"1"})," and ",(0,i.jsx)(n.code,{children:"w1"})," to ",(0,i.jsx)(n.strong,{children:"0"}),", and a value of ",(0,i.jsx)(n.strong,{children:"1"})," does the opposite. This effectively allows the animator to switch, or smoothly blend, the parent influence between ",(0,i.jsx)(n.code,{children:"skull"})," and ",(0,i.jsx)(n.code,{children:"jaw_up"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This setup gives direct artistic control over mid-face deformation while keeping the underlying rig structure simple and predictable."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"plug:\n  node: skull_mid::ctrls.0\n  slide: {k: on, min: 0, max: 1, set: $slide}\n\nconnect:\n  input: skull_mid::ctrls.0@slide\n  node: skull_mid::roots.0@w0\nconnect:\n  input: skull_mid::ctrls.0@slide\n  node: skull_mid::roots.0@w1\n  op: reverse\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"rig skull mid",src:o(6154).A+"",width:"1000",height:"730"})}),"\n",(0,i.jsx)(n.h2,{id:"mouth",children:"Mouth"}),"\n",(0,i.jsx)(n.h3,{id:"hooks",children:"Hooks"}),"\n",(0,i.jsxs)(n.p,{children:["We can now move on to the ",(0,i.jsx)(n.strong,{children:"mouth deformation rig"}),". In this section, we install the system that allows the jaws to drive the lip controllers and the various mouth tweakers that shape the deformation."]}),"\n",(0,i.jsxs)(n.p,{children:["We start by constraining the main ",(0,i.jsx)(n.code,{children:"mouth"})," controller between ",(0,i.jsx)(n.code,{children:"jaw"})," and ",(0,i.jsx)(n.code,{children:"jaw_up"})," using a ",(0,i.jsx)(n.a,{href:"/mikan-docs/references/mod/hook",children:"hook"})," modifier, following the same approach used earlier with ",(0,i.jsx)(n.code,{children:"skull_mid"}),". As before, we add a switch on this controller to define how it is attached by default, allowing us to blend or switch its parent influence."]}),"\n",(0,i.jsxs)(n.p,{children:["In addition, we introduce an ",(0,i.jsx)(n.strong,{children:"adjustable variable"})," on the helper node. This variable can be used directly inside the command, making it possible to expose only the default switch value to the artists responsible for assembling the rig, without requiring them to dig into the command logic."]}),"\n",(0,i.jsxs)(n.p,{children:["To do this, we simply declare a ",(0,i.jsx)(n.code,{children:"$variable"})," in the command in place of a numeric value. The rig builder will automatically look for the corresponding attribute named ",(0,i.jsx)(n.code,{children:"gem_var_variable"})," on the helper node. If the attribute does not exist, it will be created automatically and initialized to ",(0,i.jsx)(n.strong,{children:"0"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This approach keeps the commands flexible while making default behavior easy to adjust at build time."}),"\n",(0,i.jsxs)(n.p,{children:["Create a ",(0,i.jsx)(n.strong,{children:"helper node"})," named ",(0,i.jsx)(n.code,{children:"_mouth_hook"})," under ",(0,i.jsx)(n.code,{children:"mouth"})," module and add the following commands:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- mouth rig\nhook:  \n  nodes: mouth::roots.0  \n  targets:   \n    - jaw_up::skin.0   \n    - jaw::skin.0  \n  group: on  \n  name: jaw_mid\n\nconnect:\n  input: mouth::mod.hooks.jaw_mid@w0\n  node: mouth::mod.hooks.jaw_mid@w1\n  op: reverse\n\nplug:\n  node: mouth::mod.hooks.jaw_mid\n  w0: {set: $jaw_mid_weight}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"rig mouth",src:o(8327).A+"",width:"1228",height:"740"})}),"\n",(0,i.jsx)(n.h3,{id:"lips-rechain",children:"Lips rechain"}),"\n",(0,i.jsxs)(n.p,{children:["Now that the mouth controller is properly constrained, we can see that the main lip controllers (",(0,i.jsx)(n.code,{children:"lip_up"}),", ",(0,i.jsx)(n.code,{children:"lip_dn"}),") and the mouth corners (",(0,i.jsx)(n.code,{children:"lips_corner.L"}),", ",(0,i.jsx)(n.code,{children:"lips_corner.R"}),") do not automatically follow it. A straightforward solution would be to parent everything directly under ",(0,i.jsx)(n.code,{children:"mouth"}),", but that would be too limiting. In practice, we want ",(0,i.jsx)(n.code,{children:"lip_up"})," and ",(0,i.jsx)(n.code,{children:"lip_dn"})," to continue following their respective jaws, while still being influenced by the global mouth control."]}),"\n",(0,i.jsxs)(n.p,{children:["To achieve this, we introduce the concept of a ",(0,i.jsx)(n.strong,{children:"virtual hierarchy"})," using the ",(0,i.jsx)(n.a,{href:"/mikan-docs/references/mod/rig/rechain",children:(0,i.jsx)(n.code,{children:"rig.rechain"})})," modifier. This modifier can be a bit unintuitive at first, but once properly understood, it becomes a very powerful tool."]}),"\n",(0,i.jsxs)(n.p,{children:["The idea is simple: the physical hierarchy remains driven by the jaws, while an additional virtual parent allows the lips to inherit motion from the ",(0,i.jsx)(n.code,{children:"mouth"})," controller."]}),"\n",(0,i.jsxs)(n.p,{children:["We first create a helper node to host all commands related to the lip rig. This helper is parented under the ",(0,i.jsx)(n.code,{children:"lips"})," group and named ",(0,i.jsx)(n.code,{children:"_lips_rig"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["We then add commands to parent ",(0,i.jsx)(n.code,{children:"lip_up"})," under ",(0,i.jsx)(n.code,{children:"jaw_up"})," and ",(0,i.jsx)(n.code,{children:"lip_dn"})," under ",(0,i.jsx)(n.code,{children:"jaw"}),". This ensures that each lip controller follows its corresponding jaw by default. Once this physical hierarchy is in place, we use ",(0,i.jsx)(n.code,{children:"rig.rechain"})," to make both lip controllers also follow the ",(0,i.jsx)(n.code,{children:"mouth"})," controller, effectively inserting it as a virtual parent."]}),"\n",(0,i.jsxs)(n.p,{children:["This is also a good opportunity to introduce the notion of ",(0,i.jsx)(n.strong,{children:"execution priority"}),". The build process does not strictly follow a deterministic order based on hierarchy. While parent-child relationships define dependencies, the order in which sibling nodes are parsed cannot be guaranteed. When a specific sequence is required, timing offsets must be used to enforce it."]}),"\n",(0,i.jsxs)(n.p,{children:["In this case, we want to make sure that all constraint-related setup for the lips has already been built before applying the rechain logic. We therefore delay execution slightly using ",(0,i.jsx)(n.code,{children:"#!-10"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The resulting setup allows the lips to correctly inherit motion from both the jaws and the global mouth controller, without compromising the underlying hierarchy."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- lip up/dn rechain\n#!-10\nparent: lip_up::roots.0 jaw_up::skin.0\nparent: lip_dn::roots.0 jaw::skin.0\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - lip_up::roots.0\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - lip_dn::roots.0\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lip-tweakers-hooks",children:"Lip tweakers hooks"}),"\n",(0,i.jsx)(n.p,{children:"For the lip deformation rig, we now focus on how the mouth segmentation controllers follow the main mouth and lip controls."}),"\n",(0,i.jsxs)(n.p,{children:["The first step is to constrain all mouth tweak controllers to the global ",(0,i.jsx)(n.code,{children:"mouth"})," controls. This is done using ",(0,i.jsx)(n.code,{children:"hook"})," modifiers, with a specific weight assigned to each controller to control how much it follows. To keep the setup efficient, we group several tweak controllers under a single hook modifier whenever possible, instead of computing identical constraints multiple times."]}),"\n",(0,i.jsxs)(n.p,{children:["On the same helper node, we add modifiers to hook the ",(0,i.jsx)(n.code,{children:"mouth*"})," controllers, exposing weight attributes that control how each segment blends between ",(0,i.jsx)(n.code,{children:"mouth"})," and ",(0,i.jsx)(n.code,{children:"lip_up"})," / ",(0,i.jsx)(n.code,{children:"lip_dn"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The intended behavior is as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mouth1"})," fully follows the lips,"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mouth5"})," follows only the mouth controller,"]}),"\n",(0,i.jsx)(n.li,{children:"intermediate controllers use progressively interpolated weights."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This creates a smooth and coherent deformation along the entire mouth line, allowing global mouth motion and local lip articulation to blend naturally."}),"\n",(0,i.jsxs)(n.p,{children:["At this stage, we introduce the notion of ",(0,i.jsx)(n.strong,{children:"loops"}),", which allows a set of commands to be duplicated automatically using list-based variables. This is especially useful when you need to apply similar connections or constraints to multiple elements without repeating the same code over and over."]}),"\n",(0,i.jsxs)(n.p,{children:["To do this, we declare a variable at the beginning of the command block using the ",(0,i.jsx)(n.code,{children:"#>"})," syntax, for example: ",(0,i.jsx)(n.code,{children:"#>v: [0, 1, 2, 3]"}),".\nWhen a variable is defined as a list, any modifier that references it using ",(0,i.jsx)(n.code,{children:"<v>"})," will be executed once for each value in the list."]}),"\n",(0,i.jsx)(n.p,{children:"A declared variable does not have to be a list to be useful. If the variable contains a single value, it can still be referenced in the modifiers in exactly the same way. In that case, the commands are executed only once, but you still benefit from having a single entry point to configure a whole set of modifiers."}),"\n",(0,i.jsx)(n.p,{children:"This is particularly convenient when you want to parameterize a group of commands internally, without exposing it to an attribute. It lets you adjust indices, limits, or special cases in one place, while keeping the rest of the block generic and readable."}),"\n",(0,i.jsxs)(n.p,{children:["In the following setup, ",(0,i.jsx)(n.code,{children:"n"})," and ",(0,i.jsx)(n.code,{children:"side"})," are list-based variables used to generate repeated hooks and connections, while ",(0,i.jsx)(n.code,{children:"last"})," is a single-value variable used to handle the end controller of the mouth line explicitly. All of this is part of the same rig construction logic, not a separate example."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- lips up/dn hooks\n#>n: [2, 3, 4]\n#>last: 5\n#>side: [up, dn]\n\nhook:\n  node: mouth1_<side>::roots.0\n  targets:\n   - lip_<side>::skin.0\n  group: on\n  name: lip1_<side>\nhook:\n  node: mouth<n>_<side>::roots.0\n  targets:\n   - lip_<side>::skin.0\n   - mouth::skin.0\n  group: on\n  name: lip<n>_<side>\nhook:\n  nodes: mouth<last>::roots.0\n  targets:\n   - mouth::skin.0\n  group: on\n  name: lip<last>\n\nconnect:\n  input: lips::mod.hooks.lip<n>_<side>@w0\n  node: lips::mod.hooks.lip<n>_<side>@w1\n  op: reverse\n\nplug:\n  node: lips::mod.hooks.lip<n>_<side>\n  w0: {set: $mouth<n>_<side>_weight}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lips-corner-pinch",children:"Lips corner pinch"}),"\n",(0,i.jsx)(n.p,{children:"At this stage, a natural question arises: so far, we haven\u2019t actually set the weights for our lip tweak controllers. That\u2019s intentional. We first built the structure and relationships. Now we introduce a global control to adjust the mouth\u2019s behavior."}),"\n",(0,i.jsx)(n.p,{children:'The shape and opening of the mouth corners are sensitive parameters. They often require fine-tuning during skinning and deformation, and animators may want to tweak them directly during animation too. Rather than hard-coding these values into the rig, we expose a dedicated control that lets you adjust the "corner pinch" of the lips.'}),"\n",(0,i.jsx)(n.p,{children:"This system allows smooth transitions between a highly cartoonish mouth, wide and exaggerated, and a more realistic mouth where corners remain stable, or pinched inward."}),"\n",(0,i.jsxs)(n.p,{children:["We achieve this by adding an animation attribute to the main mouth controller, then using it to drive the weights of the lip tweak hooks. Default weight values remain defined via exposed template variables (with ",(0,i.jsx)(n.code,{children:"$"}),"), while the distribution logic uses the loop variables introduced earlier. Both systems work together seamlessly."]}),"\n",(0,i.jsx)(n.p,{children:"The following block extends the previous exercise:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- sticky corner switch\n#> n: ['2', '3', '4']\n#> side: [up, dn]\nplug:\n  node: mouth::ctrls.0\n  corners_pinch: {set: 0, k: on, min: -1, max: 1}\n\ndrive:\n  node: mouth::ctrls.0@corners_pinch\n  lips::mod.hooks.lip<n>_<side>@w0:\n    1: $mouth<n>_<side>_weight\n    0: $mouth<n>_<side>_weight\n    -1: 1\n\ndrive:\n  node: mouth::ctrls.0@corners_pinch\n  lips::mod.hooks.lip3_<side>@w0:\n    1: 0\n    0: $mouth3_<side>_weight\n    -1: 1\n"})}),"\n",(0,i.jsx)(n.h3,{id:"combining-lips-corner-tweakers",children:"Combining lips corner tweakers"}),"\n",(0,i.jsxs)(n.p,{children:["The final step of the mouth controller setup is to attach the corner tweakers to the ",(0,i.jsx)(n.code,{children:"lips_corner"})," controllers. First, we need to reparent the ",(0,i.jsx)(n.code,{children:"lips_corner"})," under the global ",(0,i.jsx)(n.code,{children:"mouth"})," controller. In the template, they were placed in the ",(0,i.jsx)(n.code,{children:"lips"})," group to be associated with animator tools, but for the final rig structure, we need to establish the proper hierarchy. This also shows the flexibility of Mikan: you can move elements in the template without breaking the rig."]}),"\n",(0,i.jsxs)(n.p,{children:["Next, we want to virtually reparent the tweakers, ",(0,i.jsx)(n.code,{children:"mouth4_up"}),", ",(0,i.jsx)(n.code,{children:"mouth4_dn"}),", and ",(0,i.jsx)(n.code,{children:"mouth5"}),", to follow the ",(0,i.jsx)(n.code,{children:"lips_corner"})," while keeping the existing hook weights intact. To do this, we use the ",(0,i.jsx)(n.a,{href:"/mikan-docs/references/mod/rig/rechain",children:(0,i.jsx)(n.code,{children:"rig.rechain"})})," modifier, which requires temporary reference objects. Instead of creating additional template modules, we can generate these on the fly using the ",(0,i.jsx)(n.a,{href:"/mikan-docs/references/mod/locator",children:(0,i.jsx)(n.code,{children:"locator"})})," modifier. This is ideal for small helper nodes or groups needed to complete the rig, without cluttering the template hierarchy. If the locator duplicates an existing rig object, this approach works perfectly."]}),"\n",(0,i.jsx)(n.p,{children:"How it works:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"locator"})," modifier generates two reference objects for each tweaker: one for the original position, and one attached to the ",(0,i.jsx)(n.code,{children:"lips_corner"})," hook."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"parent"})," command sets the tweaker under the appropriate controllers so the hierarchy exists for the rechain."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rig.rechain"})," then virtually re-parents the tweakers to follow ",(0,i.jsx)(n.code,{children:"lips_corner"})," while preserving the influence of the weighted hooks."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This system allows the corners of the mouth to drive the tweakers without breaking previous lip constraints. It demonstrates the flexibility of Mikan: you can insert helper locators, virtual parents, or control nodes wherever needed, keeping the rig adaptable and maintainable."}),"\n",(0,i.jsxs)(n.p,{children:["To do this, create another helper node named ",(0,i.jsx)(n.code,{children:"_lips_corner_rig"})," under ",(0,i.jsx)(n.code,{children:"lips"})," group and add the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- mouth corner rig\n#!-20\n#> lip: [4_up, 5, 4_dn]\n\nparent:\n  - lips_corner::roots.0\n  - mouth::hooks.0\n\n# create locators for the original and destination positions\nlocator:\n  node: mouth<lip>.L::ctrls.0\n  parent: mouth::skin.0\n  name: orig_mouth_<lip>\n\nlocator:\n  node: mouth<lip>.L::ctrls.0\n  parent: lips::mod.hooks.lip<lip>\n  name: mouth_<lip>\n\n# parent the tweaker under the lips_corner controller\nparent:\n  - mouth<lip>.L::roots.0\n  - lips_corner.L::skin.0\n\n# use rig.rechain to create a virtual hierarchy\nrig.rechain:\n  roots:\n   - lips_corner.L::mod.loc.orig_mouth_<lip>\n  ctrls:\n   - lips_corner.L::mod.loc.mouth_<lip>\n  nodes:\n   - mouth<lip>.L::roots.0\n"})}),"\n",(0,i.jsx)(n.h3,{id:"sticky-lips",children:"Sticky lips"}),"\n",(0,i.jsxs)(n.p,{children:["We start by creating the sticky attributes on ",(0,i.jsx)(n.strong,{children:"shp_lips"}),", which will later be connected to chan_face for animator access."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- sticky lips settings\n#!10\n\nplug:\n m_sticky_L: {add: float, k: on, set: 0, min: 0, max: 2}\n m_sticky_R: {add: float, k: on, set: 0, min: 0, max: 2}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We then set up the ",(0,i.jsx)(n.strong,{children:"sticky rig"})," by creating a helper ",(0,i.jsx)(n.strong,{children:"node"})," under the Lips group."]}),"\n",(0,i.jsxs)(n.p,{children:["We first create ",(0,i.jsx)(n.strong,{children:"midpoint locators"})," between up and dn for ",(0,i.jsx)(n.strong,{children:"lip1, lip2, and lip3"}),", then reference locators for up/dn positions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- sticky lips rig\n#!-5\n\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip1_mid\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2_mid.L\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2b_mid.L \nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip3_mid.L\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2_mid.R\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2b_mid.R\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip3_mid.R\n\n\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip1_mid\n  targets:\n   - mouth1_up::poses\n   - mouth1_dn::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2_mid.L\n  targets:\n   - mouth2_up.L::poses\n   - mouth2_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2b_mid.L\n  targets:\n   - mouth2b_up.L::poses\n   - mouth2b_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip3_mid.L\n  targets:\n   - mouth3_up.L::poses\n   - mouth3_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2_mid.R\n  targets:\n   - mouth2_up.R::poses\n   - mouth2_dn.R::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2b_mid.R\n  targets:\n   - mouth2b_up.R::poses\n   - mouth2b_dn.R::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip3_mid.R\n  targets:\n   - mouth3_up.R::poses\n   - mouth3_dn.R::poses\n\nlocator:\n  node: lip1_up::roots.0\n  parent: lips::mod.loc.lip1_mid\n  name: lip1_up\nlocator:\n  node: lip2_up.L::roots.0\n  parent: lips::mod.loc.lip2_mid.L\n  name: lip2_up.L\nlocator:\n  node: lip2b_up.L::roots.0\n  parent: lips::mod.loc.lip2b_mid.L\n  name: lip2b_up.L\nlocator:\n  node: lip3_up.L::roots.0\n  parent: lips::mod.loc.lip3_mid.L\n  name: lip3_up.L\nlocator:\n  node: lip2_up.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2_up.R\nlocator:\n  node: lip2b_up.R::roots.0\n  parent: lips::mod.loc.lip2b_mid.R\n  name: lip2b_up.R\nlocator:\n  node: lip3_up.R::roots.0\n  parent: lips::mod.loc.lip3_mid.R\n  name: lip3_up.R\n\nlocator:\n  node: lip1_dn::roots.0\n  parent: lips::mod.loc.lip1_mid\n  name: lip1_dn\nlocator:\n  node: lip2_dn.L::roots.0\n  parent: lips::mod.loc.lip2_mid.L\n  name: lip2_dn.L\nlocator:\n  node: lip2b_dn.L::roots.0\n  parent: lips::mod.loc.lip2b_mid.L\n  name: lip2b_dn.L\nlocator:\n  node: lip3_dn.L::roots.0\n  parent: lips::mod.loc.lip3_mid.L\n  name: lip3_dn.L\nlocator:\n  node: lip2_dn.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2_dn.R\nlocator:\n  node: lip2b_dn.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2b_dn.R\nlocator:\n  node: lip3_dn.R::roots.0\n  parent: lips::mod.loc.lip3_mid.R\n  name: lip3_dn.R\n\n\nhook:\n  node: lip1_up::infs.0\n  target: lips::mod.loc.lip1_up\n  weights: [1]\n\nhook:\n  node: lip1_dn::infs.0\n  target: lips::mod.loc.lip1_dn\n  weights: [1]\n\nhook:\n  node: lip2_up.L::infs.0\n  target: lips::mod.loc.lip2_up.L\n  weights: [1]\n\nhook:\n  node: lip2_dn.L::infs.0\n  target: lips::mod.loc.lip2_dn.L\n  weights: [1]\n\nhook:\n  node: lip2b_up.L::infs.0\n  target: lips::mod.loc.lip2b_up.L\n  weights: [1]\n\nhook:\n  node: lip2b_dn.L::infs.0\n  target: lips::mod.loc.lip2b_dn.L\n  weights: [1]\n\nhook:\n  node: lip3_up.L::infs.0\n  target: lips::mod.loc.lip3_up.L\n  weights: [1]\n\nhook:\n  node: lip3_dn.L::infs.0\n  target: lips::mod.loc.lip3_dn.L\n  weights: [1]\n\nhook:\n  node: lip2_up.R::infs.0\n  target: lips::mod.loc.lip2_up.R\n  weights: [1]\n\nhook:\n  node: lip2_dn.R::infs.0\n  target: lips::mod.loc.lip2_dn.R\n  weights: [1]\n\nhook:\n  node: lip2b_up.R::infs.0\n  target: lips::mod.loc.lip2b_up.R\n  weights: [1]\n\nhook:\n  node: lip2b_dn.R::infs.0\n  target: lips::mod.loc.lip2b_dn.R\n  weights: [1]\n\nhook:\n  node: lip3_up.R::infs.0\n  target: lips::mod.loc.lip3_up.R\n  weights: [1]\n\nhook:\n  node: lip3_dn.R::infs.0\n  target: lips::mod.loc.lip3_dn.R\n  weights: [1]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finally, we set up the drives and expressions controlling the sticky behavior."}),"\n",(0,i.jsx)(n.p,{children:"Start with values that seem reasonable. You can adjust them as you test the rig."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"drive:\n  node: shp_lips::node@m_sticky_L\n  shp_lips::node@s3l:\n    0: {v: 0, tan: linear}\n    0.25: {v: 0.5, ox: 0.25, oy: 0.5}\n    1: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2bl:\n    0: {v: 0, tan: flat}\n    0.375: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2l:\n    0: {v: 0, tan: flat}\n    0.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s1:\n    0.25: {v: 0, tan: flat}\n    1: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.75: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2r:\n    0.75: {v: 0, tan: flat}\n    1.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2br:\n    0.75: {v: 0, tan: flat}\n    1.625: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s3r:\n    1: {v: 0, tan: flat}\n    1.75: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: linear}\n    pre: constant\n    post: constant\n\ndrive:\n  node: shp_lips::node@m_sticky_R\n  shp_lips::node@s3r:\n    0: {v: 0, tan: linear}\n    0.25: {v: 0.5, ox: 0.25, oy: 0.5}\n    1: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  node: shp_lips::node@m_sticky_R\n  shp_lips::node@s2br:\n    0: {v: 0, tan: flat}\n    0.375: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2r:\n    0: {v: 0, tan: flat}\n    0.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s1:\n    0.25: {v: 0, tan: flat}\n    1: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.75: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2l:\n    0.75: {v: 0, tan: flat}\n    1.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2bl:\n    0.75: {v: 0, tan: flat}\n    1.625: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s3l:\n    1: {v: 0, tan: flat}\n    1.75: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: linear}\n    pre: constant\n    post: constant\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip3_up.L::infs.0@w0\n  x: shp_lips::node@s3l\n\nconnect:\n  input: lip3_up.L::infs.0@w0\n  node: lip3_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2b_up.L::infs.0@w0\n  x: shp_lips::node@s2bl\nconnect:\n  input: lip2b_up.L::infs.0@w0\n  node: lip2b_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2_up.L::infs.0@w0\n  x: shp_lips::node@s2l\n\nconnect:\n  input: lip2_up.L::infs.0@w0\n  node: lip2_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip1_up::infs.0@w0\n  x: shp_lips::node@s1\n\nconnect:\n  input: lip1_up::infs.0@w0\n  node: lip1_dn::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2_up.R::infs.0@w0\n  x: shp_lips::node@s2r\n\nconnect:\n  input: lip2_up.R::infs.0@w0\n  node: lip2_dn.R::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2b_up.R::infs.0@w0\n  x: shp_lips::node@s2br\n\nconnect:\n  input: lip2b_up.R::infs.0@w0\n  node: lip2b_dn.R::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip3_up.R::infs.0@w0\n  x: shp_lips::node@s3r\n\nconnect:\n  input: lip3_up.R::infs.0@w0\n  node: lip3_dn.R::infs.0@w0\n"})}),"\n",(0,i.jsx)(n.h3,{id:"teeth-rechain-and-teeth-grab",children:"Teeth rechain and teeth grab"}),"\n",(0,i.jsxs)(n.p,{children:["Following the same logic, we rig the ",(0,i.jsx)(n.strong,{children:"teeth"})," so they can ",(0,i.jsx)(n.strong,{children:"follow (or not) c_mouth"}),".\nWe create a ",(0,i.jsx)(n.strong,{children:"virtual hierarchy"})," between c_mouth and c_teeth, using the weight option to enable or disable the transform constraint."]}),"\n",(0,i.jsx)(n.p,{children:"We then add an attribute on c_mouth to control the weight of this constraint."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\n# -- teeth subtransform\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - teeth_up::roots.0\n  weight: on\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - teeth_dn::roots.0\n  weight: on\n\nplug:\n  node: mouth::ctrls.0\n  grab_teeth:\n    k: on\n    min: 0\n    max: 1\n\nconnect:\n  input: mouth::ctrls.0@grab_teeth\n  node: teeth_up::roots.0@weight\nconnect:\n  input: mouth::ctrls.0@grab_teeth\n  node: teeth_dn::roots.0@weight\n"})}),"\n",(0,i.jsx)(n.h3,{id:"sticky-teeth",children:"Sticky teeth"}),"\n",(0,i.jsxs)(n.p,{children:["The principle is the ",(0,i.jsx)(n.strong,{children:"same"})," as with the sticky lips, except the sticky should ",(0,i.jsx)(n.strong,{children:"activate uniformly"})," across all teeth.\nWe create a ",(0,i.jsx)(n.strong,{children:"_sticky_teeth helper node"})," under the Lips group to store these modifiers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\nlocator:\n  node: teeth_dn::skin.0\n  parent: jaw::skin.0\n  name: teeth_mid\n\nhook:\n  self: on\n  targets:\n    - teeth_up::skin.0\n    - teeth_dn::skin.0\n  node: lips::mod.loc.teeth_mid\n  weights: [0.5, 0.5]\n\n#> y: [up, dn]\n#> x: [L, R]\nlocator:\n  node: teeth_bend_<y>.<x>::poses.0\n  parent: lips::mod.loc.teeth_mid\n  name: copy_teeth_tip_<y>_<x>\n  copycat: on\n\nlocator:\n  node: teeth_tip_<y>::hooks.0\n  parent: lips::mod.loc.teeth_mid\n  name: teeth_tip_<y>\nlocator:\n  node: teeth_bend_tip_<y>.<x>::hooks.0\n  parent: lips::mod.loc.copy_teeth_tip_<y>_<x>\n  name: teeth_tip_<y>_<x>\n\nhook:\n  target: lips::mod.loc.teeth_tip_<y>\n  node: teeth_tip_<y>::roots.0\n  weights: [1]\nhook:\n  target: lips::mod.loc.teeth_tip_<y>_<x>\n  node: teeth_bend_tip_<y>.<x>::roots.0\n  weights: [1]\n\n\nplug:\n  node: shp_lips::node\n  t_sticky: {type: float, k: on}\n\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_tip_<y>::roots.0@w0\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_tip_<y>::roots.0@w1\n  op: reverse\n\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_bend_tip_<y>.<x>::roots.0@w0\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_bend_tip_<y>.<x>::roots.0@w1\n  op: reverse\n"})}),"\n",(0,i.jsx)(n.h2,{id:"cheeks",children:"Cheeks"}),"\n",(0,i.jsxs)(n.p,{children:["Next, we rig the ",(0,i.jsx)(n.strong,{children:"cheeks"})," by attaching their controllers to the facial structure.\nWe add ",(0,i.jsx)(n.strong,{children:"hook"})," modifiers on a helper node placed under skull_mid."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\nparent:\n  - chin::roots\n  - jaw::hooks.0\n\nhook:\n  nodes:\n   - cheek1::roots\n   - nasolabial1::roots\n  targets:\n   - jaw_up::skin.0\n   - jaw::skin.0\n  parent: neck::hooks.head\n  name: cheek_mid\n\nhook:\n  nodes:\n   - cheek2::roots\n   - cheek3::roots\n  targets:\n   - skull::skin.0\n   - skull_mid::skin.0\n   - jaw_up::skin.0\n  weights: [0.35, 0.5, 0.15]\n  parent: neck::hooks.head\n  name: cheek_nose\n\nhook:\n  nodes:\n   - nasolabial2::roots\n   - lip_upper::roots\n  targets:\n   - jaw_up::skin.0\n   - skull_mid::skin.0\n  weights: [0.65, 0.35]\n  parent: neck::hooks.head\n  name: jaw_up_nose\n"})}),"\n",(0,i.jsx)(n.h2,{id:"eyebrows",children:"Eyebrows"}),"\n",(0,i.jsxs)(n.p,{children:["We finish with the eyebrows rig.\nWe add a ",(0,i.jsx)(n.strong,{children:"hook"})," constraint so the eyebrows can either ",(0,i.jsx)(n.strong,{children:"follow or ignore"})," the eyeroots.\nWe use a helper node on eyebrow_base, with a ",(0,i.jsx)(n.strong,{children:"hook"})," modifier and a ",(0,i.jsx)(n.strong,{children:"follow plug"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"[mod]\nhook:\n  self: on\n  node: eyebrow_base.L::roots.0\n  target: eye_root.L::skin.0\n  weight: 1\n\nplug:\n  node: eyebrow_base.L::ctrls.0\n  follow_skull: {set: 0, k: on, min: 0, max: 1}\n\nconnect:\n  input: eyebrow_base.L::ctrls.0@follow_skull\n  op: reverse\n  node: eyebrow_base.L::roots.0@w0\n"})})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8327:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/rig_mouth-de1176b812cae40af070ba894654b74d.png"},8453:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>r});var t=o(6540);const i={},s=t.createContext(i);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);