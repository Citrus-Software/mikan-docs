"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1364],{6154:(n,e,o)=>{o.d(e,{A:()=>t});const t=o.p+"assets/images/rig_skull_mid-69e0a279ac3e331b2e39dc3f5d08d1da.png"},7406:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/facial_rig/modifiers","title":"Adding Modifiers","description":"Now that the hierarchy is in place, we move on to the most interesting part: adding all the mechanics with the modifiers.","source":"@site/docs/guides/11-facial_rig/02-modifiers.md","sourceDirName":"guides/11-facial_rig","slug":"/guides/facial_rig/modifiers","permalink":"/mikan-docs/guides/facial_rig/modifiers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Template Hierarchy","permalink":"/mikan-docs/guides/facial_rig/templates"},"next":{"title":"Animator Interface","permalink":"/mikan-docs/guides/facial_rig/ui"}}');var s=o(4848),i=o(8453);const l={},r="Adding Modifiers",a={},d=[{value:"Visibility groups",id:"visibility-groups",level:2},{value:"Skull hooks",id:"skull-hooks",level:2},{value:"Mouth",id:"mouth",level:2},{value:"Hooks",id:"hooks",level:3},{value:"Lips rechain",id:"lips-rechain",level:3},{value:"Lips hooks",id:"lips-hooks",level:3},{value:"Lips corner pinch",id:"lips-corner-pinch",level:3},{value:"Teeth rechain and teeth grab",id:"teeth-rechain-and-teeth-grab",level:3},{value:"Combining lips corner tweakers",id:"combining-lips-corner-tweakers",level:3},{value:"Sticky lips",id:"sticky-lips",level:3},{value:"Sticky teeth",id:"sticky-teeth",level:3},{value:"Cheeks",id:"cheeks",level:2},{value:"Eyebrows",id:"eyebrows",level:2}];function p(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"adding-modifiers",children:"Adding Modifiers"})}),"\n",(0,s.jsx)(e.p,{children:"Now that the hierarchy is in place, we move on to the most interesting part: adding all the mechanics with the modifiers."}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"Reminder: in Mikan, we do not use direct constraints in Maya.\nWe use modifiers, which are instructions read by Mikan during the rig build.\nThis keeps the template clean and flexible."})}),"\n",(0,s.jsx)(e.h2,{id:"visibility-groups",children:"Visibility groups"}),"\n",(0,s.jsx)(e.p,{children:"Let's start with simple modifiers to add visibility groups to the facial-rig controllers."}),"\n",(0,s.jsxs)(e.p,{children:["Groups in the hierarchy gather controllers for select/mirror/flip, but they do not create visibility menus.\nSo we add a ",(0,s.jsx)(e.strong,{children:"helper node"})," named ",(0,s.jsx)(e.code,{children:"_face_vis"})," on the face group, then a ",(0,s.jsx)(e.a,{href:"/mikan-docs/references/mod/group",children:"group"})," modifier to create the visibility menus."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- facial visibility groups\n#?neck::ctrls.head\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - face:::ctrls \n  tag: vis.face\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - mouth1*::ctrls  \n    - mouth2*::ctrls  \n    - mouth3*::ctrls  \n    - mouth4*::ctrls \n  tag: vis.mouth\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - lip1*::ctrls  \n    - lip2*::ctrls  \n    - lip3*::ctrls  \n    - lip4*::ctrls \n  tag: vis.lips\n\ngroup: \n  vis: neck::ctrls.head \n  nodes:  \n    - cheeks:::ctrls   \n  tag: vis.cheeks\n"})}),"\n",(0,s.jsx)(e.p,{children:"A few important points to keep in mind when working with controller groups:"}),"\n",(0,s.jsxs)(e.p,{children:["The command ",(0,s.jsx)(e.code,{children:"#?neck::ctrls.head"})," ensures that the block only executes if the specified object exists. At first glance, it may seem unnecessary, but it becomes very useful when you want to reuse or extend this template for different characters, allowing you to safely run commands without affecting other rigs that may not share the same hierarchy."]}),"\n",(0,s.jsxs)(e.p,{children:["Another option is to declare a variable like that: ",(0,s.jsx)(e.code,{children:"#>ctrl: neck::ctrls.head"}),". This lets you replace all occurrences of this controller in the block with ",(0,s.jsx)(e.code,{children:"<ctrl>"}),", making it easy to edit all commands at once using a single variable."]}),"\n",(0,s.jsxs)(e.p,{children:["The triple-colon notation in ",(0,s.jsx)(e.code,{children:"face:::ctrls"})," is used to select the group and all of its children. Using ",(0,s.jsx)(e.code,{children:"face::ctrls"})," (double colon) would select only the direct members of the face group, but in our setup, the face group itself contains no controllers. Extending the selection with ",(0,s.jsx)(e.code,{children:":::"})," ensures that all controllers within the hierarchy are included in the operation."]}),"\n",(0,s.jsx)(e.h2,{id:"skull-hooks",children:"Skull hooks"}),"\n",(0,s.jsxs)(e.p,{children:["Let's add the modifiers required to rig ",(0,s.jsx)(e.strong,{children:"skull_mid"}),".\nWe first attach skull_mid using a ",(0,s.jsx)(e.strong,{children:"hook"})," modifier between ",(0,s.jsx)(e.strong,{children:"skull"})," and ",(0,s.jsx)(e.strong,{children:"jaw_up"}),"."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- skull mid hooks\n\nhook:\n  nodes:\n   - skull_mid::roots\n  targets: \n   - skull::skin.0\n   - jaw_up::skin.0\n  self: on\n"})}),"\n",(0,s.jsxs)(e.p,{children:["We then create an attribute to ",(0,s.jsx)(e.strong,{children:"manage the follow"})," between the two targets, using a ",(0,s.jsx)(e.strong,{children:"plug"})," modifier."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\nplug:\n  node: skull_mid::ctrls.0\n  slide: {k: on, min: 0, max: 1, set: $slide}\n\nconnect:\n  input: skull_mid::ctrls.0@slide\n  node: skull_mid::roots.0@w0\nconnect:\n  input: skull_mid::ctrls.0@slide\n  op: reverse\n  node: skull_mid::roots.0@w1\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"rig skull mid",src:o(6154).A+"",width:"1000",height:"730"})}),"\n",(0,s.jsx)(e.h2,{id:"mouth",children:"Mouth"}),"\n",(0,s.jsx)(e.h3,{id:"hooks",children:"Hooks"}),"\n",(0,s.jsxs)(e.p,{children:["We want ",(0,s.jsx)(e.strong,{children:"c_mouth"})," to be attached to ",(0,s.jsx)(e.strong,{children:"jaw"})," and ",(0,s.jsx)(e.strong,{children:"jaw_up"}),".\nWe create a ",(0,s.jsx)(e.strong,{children:"hook"})," modifier, synchronize its weights via a ",(0,s.jsx)(e.strong,{children:"connect"}),", and add a ",(0,s.jsx)(e.strong,{children:"plug"})," to easily adjust the blend."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- mouth rig\nhook:  \n  nodes: mouth::roots.0  \n  targets:   \n    - jaw_up::skin.0   \n    - jaw::skin.0  \n  group: on  \n  name: jaw_mid\n\nconnect:\n  input: mouth::mod.hooks.jaw_mid@w0\n  node: mouth::mod.hooks.jaw_mid@w1\n  op: reverse\n\nplug:\n  node: mouth::mod.hooks.jaw_mid\n  w0: {set: $jaw_mid_weight}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"rig mouth",src:o(8327).A+"",width:"1228",height:"740"})}),"\n",(0,s.jsx)(e.h3,{id:"lips-rechain",children:"Lips rechain"}),"\n",(0,s.jsxs)(e.p,{children:["We want ",(0,s.jsx)(e.strong,{children:"mouth"})," and the ",(0,s.jsx)(e.strong,{children:"lips"})," to ",(0,s.jsx)(e.strong,{children:"follow jaw"}),", ",(0,s.jsx)(e.strong,{children:"jaw_up"}),", and ",(0,s.jsx)(e.strong,{children:"c_mouth"}),". To achieve this, we create a ",(0,s.jsx)(e.strong,{children:"_lips_mod"})," helper node on the lips group."]}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"This cannot be done with simple parenting or constraints, as it would break the hierarchical dependencies."})}),"\n",(0,s.jsxs)(e.p,{children:["We use a ",(0,s.jsx)(e.a,{href:"/mikan-docs/references/mod/rig/rechain",children:"rig.rechain"})," modifier to create a parallel virtual hierarchy and accumulate the influences.\nFirst, we parent ",(0,s.jsx)(e.code,{children:"lip_up"})," under ",(0,s.jsx)(e.code,{children:"jaw_up"})," and ",(0,s.jsx)(e.code,{children:"lip_dn"})," under ",(0,s.jsx)(e.code,{children:"jaw"}),".\nThen we add the rig.rechain so that the lips also follow ",(0,s.jsx)(e.code,{children:"mouth"})," controller."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n#!-10\n\nparent: lip_up::roots.0 jaw_up::skin.0\nparent: lip_dn::roots.0 jaw::skin.0\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - lip_up::roots.0\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - lip_dn::roots.0\n"})}),"\n",(0,s.jsx)(e.h3,{id:"lips-hooks",children:"Lips hooks"}),"\n",(0,s.jsx)(e.p,{children:"On the same helper node, we add modifiers to hook the c_mouth controllers with weight attributes, so we can manage the follow between mouth and lip_up / lip_dn."}),"\n",(0,s.jsx)(e.p,{children:"The intended behavior is:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"mouth1"})," fully follows the lips,"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"mouth4"})," stays entirely on mouth,"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"intermediate controllers"})," have ",(0,s.jsx)(e.strong,{children:"progressive follow values"}),"."]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"This gives a coherent and smooth deformation across the entire mouth line."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- lips up/dn hooks\n#> n: ['2', '2b', '3']\n#> side: [up, dn]\n\nhook:\n  node: mouth1_<side>::roots.0\n  targets:\n   - lip_<side>::skin.0\n  group: on\n  name: lip1_<side>\nhook:\n  node: mouth<n>_<side>::roots.0\n  targets:\n   - lip_<side>::skin.0\n   - mouth::skin.0\n  group: on\n  name: lip<n>_<side>\nhook:\n  nodes: mouth4::roots.0\n  targets:\n   - mouth::skin.0\n  group: on\n  name: lip4\n\nconnect:\n  input: lips::mod.hooks.lip<n>_<side>@w0\n  node: lips::mod.hooks.lip<n>_<side>@w1\n  op: reverse\n\nplug:\n  node: lips::mod.hooks.lip<n>_<side>\n  w0: {set: $mouth<n>_<side>_weight}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"lips-corner-pinch",children:"Lips corner pinch"}),"\n",(0,s.jsxs)(e.p,{children:["Still on the same helper, we add the modifiers to build a ",(0,s.jsx)(e.strong,{children:"sticky corner"})," system.\nWe create a ",(0,s.jsx)(e.strong,{children:"corners_pinch attribute"}),", then connect it to the ",(0,s.jsx)(e.strong,{children:"weights"})," of the hooks for mouth2 and mouth3."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky corner switch\n#> n: ['2', '2b']\n#> side: [up, dn]\nplug:\n  node: mouth::ctrls.0\n  corners_pinch: {set: 0, k: on, min: -1, max: 1}\n\ndrive:\n  node: mouth::ctrls.0@corners_pinch\n  lips::mod.hooks.lip<n>_<side>@w0:\n    1: $mouth<n>_<side>_weight\n    0: $mouth<n>_<side>_weight\n    -1: 1\n\ndrive:\n  node: mouth::ctrls.0@corners_pinch\n  lips::mod.hooks.lip3_<side>@w0:\n    1: 0\n    0: $mouth3_<side>_weight\n    -1: 1\n"})}),"\n",(0,s.jsx)(e.h3,{id:"teeth-rechain-and-teeth-grab",children:"Teeth rechain and teeth grab"}),"\n",(0,s.jsxs)(e.p,{children:["Following the same logic, we rig the ",(0,s.jsx)(e.strong,{children:"teeth"})," so they can ",(0,s.jsx)(e.strong,{children:"follow (or not) c_mouth"}),".\nWe create a ",(0,s.jsx)(e.strong,{children:"virtual hierarchy"})," between c_mouth and c_teeth, using the weight option to enable or disable the transform constraint."]}),"\n",(0,s.jsx)(e.p,{children:"We then add an attribute on c_mouth to control the weight of this constraint."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- teeth subtransform\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - teeth_up::roots.0\n  weight: on\n\nrig.rechain:\n  roots:\n   - mouth::roots.0\n  ctrls:\n   - mouth::skin.0\n  nodes:\n   - teeth_dn::roots.0\n  weight: on\n\nplug:\n  node: mouth::ctrls.0\n  grab_teeth:\n    k: on\n    min: 0\n    max: 1\n\nconnect:\n  input: mouth::ctrls.0@grab_teeth\n  node: teeth_up::roots.0@weight\nconnect:\n  input: mouth::ctrls.0@grab_teeth\n  node: teeth_dn::roots.0@weight\n"})}),"\n",(0,s.jsx)(e.h3,{id:"combining-lips-corner-tweakers",children:"Combining lips corner tweakers"}),"\n",(0,s.jsx)(e.p,{children:"We now set up the connections so that mouth3 up/dn and mouth4 are driven by both c_mouth and c_corner, while still following lip_up and lip_dn."}),"\n",(0,s.jsx)(e.p,{children:"To do this, we again use rig.rechain, which allows us to build a virtual hierarchy without breaking existing dependencies."}),"\n",(0,s.jsx)(e.p,{children:"The order of the constraints is essential:\nthe mouth controllers must follow c_corner first, then lip_up/dn."}),"\n",(0,s.jsx)(e.p,{children:"We proceed as follows:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Create locators under sk_mouth."}),"\n",(0,s.jsx)(e.li,{children:"Create additional locators under the hooks of mouth3 and mouth4, replacing the controllers."}),"\n",(0,s.jsx)(e.li,{children:"Reparent the mouth controllers under c_corner."}),"\n",(0,s.jsx)(e.li,{children:"Rebuild the hierarchy between the hooks and controllers using rig.rechain."}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- mouth corner rig (subtransforms)\n\n#!-10\n#> lip: ['3_up', '4', '3_dn']\n\nlocator:\n  node: mouth<lip>.L::ctrls.0\n  parent: mouth::skin.0\n  name: orig_mouth_<lip>\n\nlocator:\n  node: mouth<lip>.L::ctrls.0\n  parent: lips::mod.hooks.lip<lip>\n  name: mouth_<lip>\n\nparent:\n  - mouth<lip>.L::roots.0\n  - lips_corner.L::skin.0\n\nrig.rechain:\n  roots:\n   - lips_corner.L::mod.loc.orig_mouth_<lip>\n  ctrls:\n   - lips_corner.L::mod.loc.mouth_<lip>\n  nodes:\n   - mouth<lip>.L::roots.0\n"})}),"\n",(0,s.jsx)(e.h3,{id:"sticky-lips",children:"Sticky lips"}),"\n",(0,s.jsxs)(e.p,{children:["We start by creating the sticky attributes on ",(0,s.jsx)(e.strong,{children:"shp_lips"}),", which will later be connected to chan_face for animator access."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky lips settings\n#!10\n\nplug:\n m_sticky_L: {add: float, k: on, set: 0, min: 0, max: 2}\n m_sticky_R: {add: float, k: on, set: 0, min: 0, max: 2}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["We then set up the ",(0,s.jsx)(e.strong,{children:"sticky rig"})," by creating a helper ",(0,s.jsx)(e.strong,{children:"node"})," under the Lips group."]}),"\n",(0,s.jsxs)(e.p,{children:["We first create ",(0,s.jsx)(e.strong,{children:"midpoint locators"})," between up and dn for ",(0,s.jsx)(e.strong,{children:"lip1, lip2, and lip3"}),", then reference locators for up/dn positions."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\n# -- sticky lips rig\n#!-5\n\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip1_mid\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2_mid.L\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2b_mid.L \nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip3_mid.L\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2_mid.R\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip2b_mid.R\nlocator:\n  parent: lips::mod.hooks.jaw_mid\n  name: lip3_mid.R\n\n\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip1_mid\n  targets:\n   - mouth1_up::poses\n   - mouth1_dn::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2_mid.L\n  targets:\n   - mouth2_up.L::poses\n   - mouth2_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2b_mid.L\n  targets:\n   - mouth2b_up.L::poses\n   - mouth2b_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip3_mid.L\n  targets:\n   - mouth3_up.L::poses\n   - mouth3_dn.L::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2_mid.R\n  targets:\n   - mouth2_up.R::poses\n   - mouth2_dn.R::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip2b_mid.R\n  targets:\n   - mouth2b_up.R::poses\n   - mouth2b_dn.R::poses\nconstraint:\n  type: point\n  maintain_offset: off\n  node: lips::mod.loc.lip3_mid.R\n  targets:\n   - mouth3_up.R::poses\n   - mouth3_dn.R::poses\n\nlocator:\n  node: lip1_up::roots.0\n  parent: lips::mod.loc.lip1_mid\n  name: lip1_up\nlocator:\n  node: lip2_up.L::roots.0\n  parent: lips::mod.loc.lip2_mid.L\n  name: lip2_up.L\nlocator:\n  node: lip2b_up.L::roots.0\n  parent: lips::mod.loc.lip2b_mid.L\n  name: lip2b_up.L\nlocator:\n  node: lip3_up.L::roots.0\n  parent: lips::mod.loc.lip3_mid.L\n  name: lip3_up.L\nlocator:\n  node: lip2_up.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2_up.R\nlocator:\n  node: lip2b_up.R::roots.0\n  parent: lips::mod.loc.lip2b_mid.R\n  name: lip2b_up.R\nlocator:\n  node: lip3_up.R::roots.0\n  parent: lips::mod.loc.lip3_mid.R\n  name: lip3_up.R\n\nlocator:\n  node: lip1_dn::roots.0\n  parent: lips::mod.loc.lip1_mid\n  name: lip1_dn\nlocator:\n  node: lip2_dn.L::roots.0\n  parent: lips::mod.loc.lip2_mid.L\n  name: lip2_dn.L\nlocator:\n  node: lip2b_dn.L::roots.0\n  parent: lips::mod.loc.lip2b_mid.L\n  name: lip2b_dn.L\nlocator:\n  node: lip3_dn.L::roots.0\n  parent: lips::mod.loc.lip3_mid.L\n  name: lip3_dn.L\nlocator:\n  node: lip2_dn.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2_dn.R\nlocator:\n  node: lip2b_dn.R::roots.0\n  parent: lips::mod.loc.lip2_mid.R\n  name: lip2b_dn.R\nlocator:\n  node: lip3_dn.R::roots.0\n  parent: lips::mod.loc.lip3_mid.R\n  name: lip3_dn.R\n\n\nhook:\n  node: lip1_up::infs.0\n  target: lips::mod.loc.lip1_up\n  weights: [1]\n\nhook:\n  node: lip1_dn::infs.0\n  target: lips::mod.loc.lip1_dn\n  weights: [1]\n\nhook:\n  node: lip2_up.L::infs.0\n  target: lips::mod.loc.lip2_up.L\n  weights: [1]\n\nhook:\n  node: lip2_dn.L::infs.0\n  target: lips::mod.loc.lip2_dn.L\n  weights: [1]\n\nhook:\n  node: lip2b_up.L::infs.0\n  target: lips::mod.loc.lip2b_up.L\n  weights: [1]\n\nhook:\n  node: lip2b_dn.L::infs.0\n  target: lips::mod.loc.lip2b_dn.L\n  weights: [1]\n\nhook:\n  node: lip3_up.L::infs.0\n  target: lips::mod.loc.lip3_up.L\n  weights: [1]\n\nhook:\n  node: lip3_dn.L::infs.0\n  target: lips::mod.loc.lip3_dn.L\n  weights: [1]\n\nhook:\n  node: lip2_up.R::infs.0\n  target: lips::mod.loc.lip2_up.R\n  weights: [1]\n\nhook:\n  node: lip2_dn.R::infs.0\n  target: lips::mod.loc.lip2_dn.R\n  weights: [1]\n\nhook:\n  node: lip2b_up.R::infs.0\n  target: lips::mod.loc.lip2b_up.R\n  weights: [1]\n\nhook:\n  node: lip2b_dn.R::infs.0\n  target: lips::mod.loc.lip2b_dn.R\n  weights: [1]\n\nhook:\n  node: lip3_up.R::infs.0\n  target: lips::mod.loc.lip3_up.R\n  weights: [1]\n\nhook:\n  node: lip3_dn.R::infs.0\n  target: lips::mod.loc.lip3_dn.R\n  weights: [1]\n"})}),"\n",(0,s.jsx)(e.p,{children:"Finally, we set up the drives and expressions controlling the sticky behavior."}),"\n",(0,s.jsx)(e.p,{children:"Start with values that seem reasonable. You can adjust them as you test the rig."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"drive:\n  node: shp_lips::node@m_sticky_L\n  shp_lips::node@s3l:\n    0: {v: 0, tan: linear}\n    0.25: {v: 0.5, ox: 0.25, oy: 0.5}\n    1: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2bl:\n    0: {v: 0, tan: flat}\n    0.375: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2l:\n    0: {v: 0, tan: flat}\n    0.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s1:\n    0.25: {v: 0, tan: flat}\n    1: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.75: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2r:\n    0.75: {v: 0, tan: flat}\n    1.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2br:\n    0.75: {v: 0, tan: flat}\n    1.625: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s3r:\n    1: {v: 0, tan: flat}\n    1.75: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: linear}\n    pre: constant\n    post: constant\n\ndrive:\n  node: shp_lips::node@m_sticky_R\n  shp_lips::node@s3r:\n    0: {v: 0, tan: linear}\n    0.25: {v: 0.5, ox: 0.25, oy: 0.5}\n    1: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  node: shp_lips::node@m_sticky_R\n  shp_lips::node@s2br:\n    0: {v: 0, tan: flat}\n    0.375: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2r:\n    0: {v: 0, tan: flat}\n    0.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.25: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s1:\n    0.25: {v: 0, tan: flat}\n    1: {v: 0.5, ox: 0.25, oy: 0.5}\n    1.75: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2l:\n    0.75: {v: 0, tan: flat}\n    1.5: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s2bl:\n    0.75: {v: 0, tan: flat}\n    1.625: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: flat}\n    pre: constant\n    post: constant\n  shp_lips::node@s3l:\n    1: {v: 0, tan: flat}\n    1.75: {v: 0.5, ox: 0.25, oy: 0.5}\n    2: {v: 1, tan: linear}\n    pre: constant\n    post: constant\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip3_up.L::infs.0@w0\n  x: shp_lips::node@s3l\n\nconnect:\n  input: lip3_up.L::infs.0@w0\n  node: lip3_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2b_up.L::infs.0@w0\n  x: shp_lips::node@s2bl\nconnect:\n  input: lip2b_up.L::infs.0@w0\n  node: lip2b_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2_up.L::infs.0@w0\n  x: shp_lips::node@s2l\n\nconnect:\n  input: lip2_up.L::infs.0@w0\n  node: lip2_dn.L::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip1_up::infs.0@w0\n  x: shp_lips::node@s1\n\nconnect:\n  input: lip1_up::infs.0@w0\n  node: lip1_dn::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2_up.R::infs.0@w0\n  x: shp_lips::node@s2r\n\nconnect:\n  input: lip2_up.R::infs.0@w0\n  node: lip2_dn.R::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip2b_up.R::infs.0@w0\n  x: shp_lips::node@s2br\n\nconnect:\n  input: lip2b_up.R::infs.0@w0\n  node: lip2b_dn.R::infs.0@w0\n\nexpression:\n  op: s = clamp(x, 0, 1)\n  s: lip3_up.R::infs.0@w0\n  x: shp_lips::node@s3r\n\nconnect:\n  input: lip3_up.R::infs.0@w0\n  node: lip3_dn.R::infs.0@w0\n"})}),"\n",(0,s.jsx)(e.h3,{id:"sticky-teeth",children:"Sticky teeth"}),"\n",(0,s.jsxs)(e.p,{children:["The principle is the ",(0,s.jsx)(e.strong,{children:"same"})," as with the sticky lips, except the sticky should ",(0,s.jsx)(e.strong,{children:"activate uniformly"})," across all teeth.\nWe create a ",(0,s.jsx)(e.strong,{children:"_sticky_teeth helper node"})," under the Lips group to store these modifiers."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\nlocator:\n  node: teeth_dn::skin.0\n  parent: jaw::skin.0\n  name: teeth_mid\n\nhook:\n  self: on\n  targets:\n    - teeth_up::skin.0\n    - teeth_dn::skin.0\n  node: lips::mod.loc.teeth_mid\n  weights: [0.5, 0.5]\n\n#> y: [up, dn]\n#> x: [L, R]\nlocator:\n  node: teeth_bend_<y>.<x>::poses.0\n  parent: lips::mod.loc.teeth_mid\n  name: copy_teeth_tip_<y>_<x>\n  copycat: on\n\nlocator:\n  node: teeth_tip_<y>::hooks.0\n  parent: lips::mod.loc.teeth_mid\n  name: teeth_tip_<y>\nlocator:\n  node: teeth_bend_tip_<y>.<x>::hooks.0\n  parent: lips::mod.loc.copy_teeth_tip_<y>_<x>\n  name: teeth_tip_<y>_<x>\n\nhook:\n  target: lips::mod.loc.teeth_tip_<y>\n  node: teeth_tip_<y>::roots.0\n  weights: [1]\nhook:\n  target: lips::mod.loc.teeth_tip_<y>_<x>\n  node: teeth_bend_tip_<y>.<x>::roots.0\n  weights: [1]\n\n\nplug:\n  node: shp_lips::node\n  t_sticky: {type: float, k: on}\n\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_tip_<y>::roots.0@w0\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_tip_<y>::roots.0@w1\n  op: reverse\n\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_bend_tip_<y>.<x>::roots.0@w0\nconnect:\n  input: shp_lips::node@t_sticky\n  node: teeth_bend_tip_<y>.<x>::roots.0@w1\n  op: reverse\n"})}),"\n",(0,s.jsx)(e.h2,{id:"cheeks",children:"Cheeks"}),"\n",(0,s.jsxs)(e.p,{children:["Next, we rig the ",(0,s.jsx)(e.strong,{children:"cheeks"})," by attaching their controllers to the facial structure.\nWe add ",(0,s.jsx)(e.strong,{children:"hook"})," modifiers on a helper node placed under skull_mid."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\nparent:\n  - chin::roots\n  - jaw::hooks.0\n\nhook:\n  nodes:\n   - cheek1::roots\n   - nasolabial1::roots\n  targets:\n   - jaw_up::skin.0\n   - jaw::skin.0\n  parent: neck::hooks.head\n  name: cheek_mid\n\nhook:\n  nodes:\n   - cheek2::roots\n   - cheek3::roots\n  targets:\n   - skull::skin.0\n   - skull_mid::skin.0\n   - jaw_up::skin.0\n  weights: [0.35, 0.5, 0.15]\n  parent: neck::hooks.head\n  name: cheek_nose\n\nhook:\n  nodes:\n   - nasolabial2::roots\n   - lip_upper::roots\n  targets:\n   - jaw_up::skin.0\n   - skull_mid::skin.0\n  weights: [0.65, 0.35]\n  parent: neck::hooks.head\n  name: jaw_up_nose\n"})}),"\n",(0,s.jsx)(e.h2,{id:"eyebrows",children:"Eyebrows"}),"\n",(0,s.jsxs)(e.p,{children:["We finish with the eyebrows rig.\nWe add a ",(0,s.jsx)(e.strong,{children:"hook"})," constraint so the eyebrows can either ",(0,s.jsx)(e.strong,{children:"follow or ignore"})," the eyeroots.\nWe use a helper node on eyebrow_base, with a ",(0,s.jsx)(e.strong,{children:"hook"})," modifier and a ",(0,s.jsx)(e.strong,{children:"follow plug"}),"."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"[mod]\nhook:\n  self: on\n  node: eyebrow_base.L::roots.0\n  target: eye_root.L::skin.0\n  weight: 1\n\nplug:\n  node: eyebrow_base.L::ctrls.0\n  follow_skull: {set: 0, k: on, min: 0, max: 1}\n\nconnect:\n  input: eyebrow_base.L::ctrls.0@follow_skull\n  op: reverse\n  node: eyebrow_base.L::roots.0@w0\n"})})]})}function c(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},8327:(n,e,o)=>{o.d(e,{A:()=>t});const t=o.p+"assets/images/rig_mouth-de1176b812cae40af070ba894654b74d.png"},8453:(n,e,o)=>{o.d(e,{R:()=>l,x:()=>r});var t=o(6540);const s={},i=t.createContext(s);function l(n){const e=t.useContext(i);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);