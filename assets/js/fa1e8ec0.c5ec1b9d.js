"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7806],{3843:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>a,frontMatter:()=>t,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"references/mod/rig/rivet","title":"rig.rivet","description":"Constrains a node to a point on the surface of a mesh.","source":"@site/docs/references/mod/rig/rivet.md","sourceDirName":"references/mod/rig","slug":"/references/mod/rig/rivet","permalink":"/mikan-docs/references/mod/rig/rivet","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"rig.rechain","permalink":"/mikan-docs/references/mod/rig/rechain"},"next":{"title":"shape.channel","permalink":"/mikan-docs/references/mod/shape/channel"}}');var r=s(4848),i=s(8453);const t={},c="rig.rivet",d={},l=[{value:"Options",id:"options",level:2},{value:"Example",id:"example",level:2}];function h(e){const n={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"rigrivet",children:"rig.rivet"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Constrains a node to a point on the surface of a mesh."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This modifier allows you to attach a node to a mesh using a UV pinning system or a closest-point projection. It is useful for rivets, attachments, or sticky locators."}),"\n",(0,r.jsx)(n.p,{children:"\u26a0\ufe0f Does not work in Tangerine if the mesh scale is not (1, 1, 1)."}),"\n",(0,r.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"node"})})," (",(0,r.jsx)(n.em,{children:"node"}),", optional): The reference node used to calculate the rivet position."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"parent"})})," (",(0,r.jsx)(n.em,{children:"node"}),", optional): The node under which the rivet will be parented. Defaults to the parent of the ",(0,r.jsx)(n.code,{children:"node"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"geo"})})," (",(0,r.jsx)(n.em,{children:"node"}),"): The mesh to rivet onto (required)."]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"hook"})})," (",(0,r.jsx)(n.em,{children:"bool"}),", default: ",(0,r.jsx)(n.code,{children:"true"}),"): If true, parents the ",(0,r.jsx)(n.code,{children:"node"})," under the created rivet transform."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"orient"})}),", ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"rotate"})})," (",(0,r.jsx)(n.em,{children:"bool"}),", default: ",(0,r.jsx)(n.code,{children:"true"}),"): Aligns the rivet's orientation with the surface normal.",(0,r.jsx)(n.br,{}),"\n","\u26a0\ufe0f This defaults to ",(0,r.jsx)(n.code,{children:"false"})," when using ",(0,r.jsx)(n.code,{children:"closest"})," or ",(0,r.jsx)(n.code,{children:"keepout"})," modes."]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"uv"})})," (",(0,r.jsx)(n.em,{children:"float2"}),", optional): Specific UV coordinates to follow. Defaults to the UV closest to the node position.",(0,r.jsx)(n.br,{}),"\n","\u26a0\ufe0f Not yet supported in Tangerine."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"closest"})})," (",(0,r.jsx)(n.em,{children:"bool"})," | ",(0,r.jsx)(n.em,{children:"node"}),", default: ",(0,r.jsx)(n.code,{children:"false"}),"): Enables closest-point projection instead of UV pinning. If a node is passed, it is used as the projection source. If no node is provided, defaults to ",(0,r.jsx)(n.code,{children:"node"}),". Disables ",(0,r.jsx)(n.code,{children:"hook"})," automatically."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"raycast"})})," (",(0,r.jsx)(n.em,{children:"float3"}),", optional): A direction vector for the closest-point projection instead of using the node position."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"keepout"})})," (",(0,r.jsx)(n.em,{children:"bool"})," | ",(0,r.jsx)(n.em,{children:"node"}),", default: ",(0,r.jsx)(n.code,{children:"false"}),"): Like ",(0,r.jsx)(n.code,{children:"closest"}),", but activates only when the projection source is inside the mesh. Same source rules as ",(0,r.jsx)(n.code,{children:"closest"}),". Disables ",(0,r.jsx)(n.code,{children:"hook"})," automatically."]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"subdiv"})})," (",(0,r.jsx)(n.em,{children:"int"}),", default: ",(0,r.jsx)(n.code,{children:"0"}),"): Subdivides internally the mesh to increase projection precision."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",children:"rig.rivet:\n  geo: msh_body->shape\n  node: <id>::<node>\n  parent: <parent>::<node>\n  orient: true  # default\n"})})]})}function a(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var o=s(6540);const r={},i=o.createContext(r);function t(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);